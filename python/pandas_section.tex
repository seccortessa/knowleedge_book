\chapter{Pandas}


    En el contexto de la biblioteca `pandas` en Python, un **dataframe** es una estructura de datos bidimensional, similar a una tabla en una base de datos, una hoja de cálculo o una tabla en lenguajes estadísticos como R. Es esencialmente una colección ordenada de columnas, donde cada columna puede tener un tipo de dato diferente (número, cadena, booleano, etc.).

    El término "data tabular" se refiere precisamente a este tipo de datos en forma de tabla, donde:

    \begin{itemize}
        \item Las \textit{filas} representan observaciones o entradas individuales.
        \item Las \textit{columnas} representan características o variables de esas observaciones.
    \end{itemize}

    Matemáticamente, podríamos considerar un dataframe como una matriz \( M \) de dimensiones \( m \times n \), donde \( m \) es el número de filas y \( n \) es el número de columnas. Cada elemento \( M_{ij} \) representa el valor en la i-ésima fila y j-ésima columna.

    Un dataframe en `pandas` proporciona una serie de funcionalidades útiles para manipular y analizar datos tabulares, tales como:

    \begin{enumerate}
        \item Operaciones de filtrado y selección basadas en condiciones.
        \item Agrupaciones y operaciones de agregación.
        \item Fusiones y uniones con otros dataframes.
        \item Operaciones de pivote y reestructuración.
        \item Funcionalidades para manejo de datos faltantes.
        \item  Integración con otras bibliotecas de Python como `numpy`, `scipy` y `matplotlib`.
    \end{enumerate}1.

    Para ilustrar esto con un pequeño ejemplo, considera el siguiente dataframe:

    \[
        \begin{array}{|c|c|c|}
            \hline
            \textbf{Nombre} & \textbf{Edad} & \textbf{Profesión} \\
            \hline
            Juan            & 30            & Ingeniero          \\
            \hline
            Ana             & 25            & Doctora            \\
            \hline
            Carlos          & 28            & Arquitecto         \\
            \hline
        \end{array}
    \]

    En este dataframe:
    Las filas representan a diferentes individuos.
    Las columnas representan características de estos individuos: su nombre, edad y profesión.

    La facilidad con la que `pandas` permite manipular, filtrar y analizar este tipo de datos ha hecho que sea una herramienta esencial para cualquier persona que trabaje con análisis de datos en Python.

    \section{\texttt{Funciones de entradas y salidas}}

        Estas son las funciones mediante las cuales se pueden obtener diferentes objetos de pandas o guardar como salidas.

        \subsection{\texttt{pandas.read\_csv()}}

        Esta función es una de las más utilizadas porque importa directamente un archivo \texttt{csv} y lo convierte en un \texttt{DataFrame} (en la siguiente sección se hablará de este objeto)

            \subsubsection{Parámetros}

                \paragraph{\texttt{filepath\_or\_buffer}}

                    \begin{itemize}
                        \item \textbf{Descripción:} Es la ruta del archivo \textit{csv} a importar. Se puede usar una URL
                        \item \textbf{Tipo:} \texttt{str}. También acepta objetos tipo \texttt{PathLike} u objetos \texttt{path}.
                    \end{itemize}

                \paragraph{\texttt{sep}}

                    \begin{itemize}
                        \item \textbf{Descripción:} El tipo de separador de los datos, normalmente son comas \texttt{','} , pero puede ser configurado según el archivo que se va a importar.
                        \item \textbf{Tipo:} \texttt{str}.
                        \item \textbf{Por defecto:} \textit{','}
                    \end{itemize}

                \paragraph{\texttt{header}}

                    \begin{itemize}
                        \item \textbf{Descripción:} Es la especificación de la fila que contiene las etiquetas de las columnas. Por defecto siempre será la primera.
                        \item \textbf{Tipo:} \texttt{int} , \texttt{infer} o \texttt{None}. Si se especifica \texttt{None}, las etiquetas de las columnas serán índices desde 0 hasta n. Si se especifica \texttt{infer}, se asume que  \texttt{header = 0}
                        \item \textbf{Por defecto:} \textit{infer} .
                    \end{itemize}

                \paragraph{\texttt{index\_col}}

                    \begin{itemize}
                        \item \textbf{Descripción:} Especifica la columna que se usará como etiquetas de las filas.
                        \item \textbf{Tipo:} \texttt{hashable}. Comúnmente suelen ser del tipo numérico (\texttt{int} o \texttt{float}) o cadenas de caracteres \texttt{str}. Básicamente es la etiqueta de la columna que se usará como etiqueta
                        \item \textbf{Por defecto:}  Es opcional.
                    \end{itemize}

                \paragraph{\texttt{usecols}}

                    \begin{itemize}
                        \item \textbf{Descripción:} Se puede seleccionar un conjunto de columnas para importar y descartar las demás. Este parámetro especifica este conjunto
                        \item \textbf{Tipo:} Lista de \texttt{hashables}.
                        \item \textbf{Por defecto:} Es opcional.
                    \end{itemize}

                \paragraph{\texttt{names}}

                    \begin{itemize}
                        \item \textbf{Descripción:} Se pueden configurar manualmente los nombres de los encabezados. 
                        \item \textbf{Tipo:} Lista de \texttt{hashables}.
                        \item \textbf{Por defecto:} Es opcional.
                    \end{itemize}

                \paragraph{\texttt{skiprows}}

                    \begin{itemize}
                        \item \textbf{Descripción:} Descartar las primeras \texttt{n} filas, es esencialmente útil cuando se tiene un conjunto de datos desorganizado
                        \item \textbf{Tipo:} \texttt{Int}
                        \item \textbf{Por defecto:} Es opcional
                    \end{itemize}

                \paragraph{\texttt{skiprofooter}}

                    \begin{itemize}
                        \item \textbf{Descripción:} Exactamente igual que \texttt{skiprows}, pero con las últimas \texttt{n} filas.
                        \item \textbf{Tipo:} \texttt{Int}
                        \item \textbf{Por defecto:} Es opcional
                    \end{itemize}
        

            % \subparagraph{\texttt{}}
            % \begin{itemize}
            %     \item \textbf{Descripción:}
            %     \item \textbf{Tipo:}
            %     \item \textbf{Por defecto:}
            % \end{itemize}

            % \subparagraph{\texttt{}}
            % \subparagraph{\texttt{}}
        
        \subsection{\texttt{pandas.read\_excel()}}
        
        Los parámetros son iguales a los de los arcivos csv. Apenas existens algunas diferencias remarcables; el parámetro \texttt{usecols} puede ser implementado con los argumentos \texttt{"A:D,G"} o \texttt{":C"} para especificar las columnas de excel para usasr como las columnas. \\
        
        Adicionalmente, cuando el archivo de excel tiene más de una hoja de trabajo, Pandas por defecto solamente importa la primera, por tanto, el parámetro \texttt{sheetname}, es muy importante y útil. Se puede poner como argumento el nombre de la hoja, o el índice contando desde cero.

        \subsection{\texttt{pandas.read\_html()}}
                Si una url contiene elementos \texttt{<table>} en su html, se importarán en una lista con este método. 
        \section{Funciones generales}

        \subsection{Filtrado de información}

            Existen varios métodos para filtrar los datos de un \texttt{dataframe}. Los más básicos son los que solamente tienen una condición. También están las múltiples condiciones.

            \subsubsection{Una sola condición:} Si un dataframe con nombre \texttt{df} tiene una columna cuya etiqueta o nombre es \texttt{sex}; una forma de filtrar sería la siguiente:

                \begin{verbatim}
                    df[df.sex == "male"]
                \end{verbatim}

                De esta manera se obtiene o se retorna un dataframe con la información filtrada.

                Por su parte, se puede utilizar el método \texttt{loc} para realizar el filtrado:

                \begin{verbatim}
                    df.loc[df.sex == "male"]    
                \end{verbatim}

                Y si por ejemplo, se quiere solamente se requiere sacar una columna, se usa
                \begin{verbatim}
                    df.loc[df.sex == "male", "fare"]    
                \end{verbatim}

            \subsubsection{Varias condiciones:}


                Una forma de filtrar por el tipo de variable en el dataframe, en este caso se seleccionan una o más columnas

                \begin{verbatim}
                    mask = df.dtypes == "int64"
                    df.loc[mask]    
                \end{verbatim}

                Se pueden definir diferentes máscaras, tanto para las filas como para las columnas.

                \begin{verbatim}
                    mask1 = df["age"] >= 55
                    mask2 = df.dtypes == "int64"
                    df.loc[mask]    
                \end{verbatim}

                Adicionalmente se pueden usar funciones lógicas para mejorar la precisión del filtro:
                \begin{verbatim}
                    df.loc[(df.sex == "male") & (df.age > 25)]    
                \end{verbatim}

                Existen algunas reglas adicionales para máscaras para filtrar de forma más práctica:

                \begin{verbatim}
                    mask = summer["Year"].between(1960, 1984, inclusive = True)
                    mask2 = summer["Year"].isin([1972,1996])
                \end{verbatim}

                Este último es útil para seleccionar explícitamente un conjunto de elementos a filtrar, seleccionándolas o extrayéndolas mediante la negación. El argumento siempre es una lista con los objetos que quiero filtrar.

        \subsection{ELiminación de filas y columnas}

            Existen varias formas de eliminar filas y columnas de los dataframes. La forma más básica es mediante el método \texttt{drop}. Este método tiene el parámetro \texttt{inplace}

            \begin{verbatim}
                df.drop(columns = "col")    
            \end{verbatim}

            Para eliminar más de una columna, se pasa una lista con las etiquetas correspondientes como argumento.


            \begin{verbatim}
                df.drop(columns = ["col1", "col2"])    
            \end{verbatim}

            Dos alternativas para eliminar una columna son las siguientes.

            \begin{verbatim}
                df.drop(labels = "col_name", axis = "columns")
                del df["col"]
            \end{verbatim}

            Para eliminar las filas se utiliza la misma forma, reemplazando \texttt{columns} por \texttt{index}. Con esta forma se eliminan todas las instancias con el índice seleccionado, en caso que haya más de una fila con el mismo índice.

            \begin{verbatim}
                df.drop(index = index_name)
            \end{verbatim}

            Otra forma es renombrando el dataframe con una versión filtrada de la misma

            \begin{verbatim}
                df = df.loc[df.col == value]
            \end{verbatim}

            Aquí se seleccionan solamente las filas cuyo valor para la columna \texttt{col} es \texttt{value}, descartando todas las otras.

            Si creamos diferentes máscaras, y luego filtramos la negación lógica de dichas máscaras, entonces estaremos eliminando las filas que cumplan con la máscara o máscaras.

            \begin{verbatim}
                mask1 = summer["Year"] == 2012
                mask2 = summer["Country"] == "RUS"
                summerf = summer.loc[~(mask1 & mask2)]
            \end{verbatim}


        \subsection{Añadidura de columnas}

            La forma más básica de añadir una nueva columna es asignando un valor constante a dicha columna

            \begin{verbatim}
                df["col_nueva"] = 0
            \end{verbatim}

            Si \texttt{col\_nueva} no existe, entonces se creará y se llenará con el valor 0 para todos los índices. Si la columna ya existe, entonces se reemplazarán todos los valores con la nueva asgnación. Por su parte, si se crea una columna de la siguiente forma

            \begin{verbatim}
                df.new_col = 0
            \end{verbatim}

            En realidad se creará un nuevo atributo para el dataframe, con valor 1, pero no se creará una columna.\\

            Si se utiliza una operación tradicional con una columna del dataframe, se creará una columna nueva, y esto se puede utilizar para añadir columnas nuevas con base en datos de otras columnas:

            \begin{verbatim}
                titanic["yob"] = 1912 - titanic["age"]
            \end{verbatim}

            Para añadir una nueva columna en una posición específica, se utiliza el método \texttt{insert}:

            \begin{verbatim}
                col_new = df[col] + 3
                df.insert(loc = 6, column = "new_col_name", value = col_new)
            \end{verbatim}

            De esta forma se asegura que la columna nueva sea localizada en la sexta posición. Las columnas que estén a la derecha serán desplazadas una posición.

            Por otro lado, también se pueden añadir entradas nuevas o filas nuevas. Asignando una lista o iterable concordante con el data frame, a un nuevo índice.



        \subsection{Manupulación de valores}

            Se puede cambiar un solo valor mediante el atributo \texttt{loc} y también \texttt{iloc}

            \begin{verbatim}
                titanic.loc["index","col"] = 40
                titanic.iloc[1,1] = 40
            \end{verbatim}

            \noindent Para cambiar varios valores puede hacerse de la siguiente forma

            \begin{verbatim}
                titanic.loc[1:3, "age"] = 42
            \end{verbatim}

            \noindent Se puede cambiar un rango específico de valores con una lista de valores compatible:

            \begin{verbatim}
                titanic.iloc[1:4, 3] = [43,44,45]
            \end{verbatim}

            \noindent Recordar que con el comando \texttt{loc} si el índice es numérico, se selecciona incluyendo desde el primer número hata el último, mientras que con \texttt{iloc} se seleccionar el índice de forma tradicional como si se tratara de una lista.

            \noindent Para reemplazar o cambiar valores basado en condiciones, se usa la siguiente forma
            \begin{verbatim}
                titanic.loc[titanic.age < 1, "age"]
            \end{verbatim}

            \noindent Por su parte, si se requiere cambiar más de una columna para una entrada (fila) en particular se puede usar el siguiente código

            \begin{verbatim}
                titanic.loc[0,"survived":"age"] = [1, 2, "female", 24.0]
            \end{verbatim}

            \noindent El método \texttt{replace} es útil cuando queremos reemplazar todas las entradas que cumplan una condición

            \begin{verbatim}
                titanic.replace(0, "zero")
            \end{verbatim}

            \noindent Esto reemplaza todos los ceros que haya en la tabla por el texto "zero". \\

            \noindent Es crucial entender que al declarar una variable como referencia a una columna de una tabla, en realidad estamos creando un apuntador a dicha columna. Esto significa que cualquier cambio o reemplazo de valores en esta variable implicará una modificación directa en la columna correspondiente de la tabla:

            \begin{verbatim}
                edad = titanic.age
                edad.loc[1] = 40 # aquí
            \end{verbatim}

            \noindent En el reemplazo de variables dentro de una tala la manera correcta de realizarlo es como se mencionó en la sección anterior, realizarlo de otra forma se considera una mala práctica:

            \begin{verbatim}
                titanic.loc[1,"age"] = 40 # esta es forma correcta
                titanic.age[1] = 40 # esta no se debe relizar
            \end{verbatim}

            \noindent Por otro lado, si se asigna a una variable una o más columnas poniendo una lista como argumento, dicha variable si se modifica, no modificará la tabla original.

            \begin{verbatim}
                sexo = titanic[["sex"]]
                sexo.loc[0] = "ajefemalee"
                sexo.iloc[0] = "ajefemalee" # también aplica para iloc
                titanic # no tendrá el valor modificado
            \end{verbatim}
            
            \noindent Si se utiliza el campo para el índice \texttt{[:]} obtendremos el mismo resultado; sin embargo, al modificar una variable declarada de esta forma, Pandas no generará ninguna advertencia.
            
            \begin{verbatim}
                sexo = titanic.loc[:,["sex"]]}            
            \end{verbatim}
            
            Ahora, si se intenta reemplazar valores mediante la notación de doble paréntesis, como se muestra a continuación
            \begin{verbatim}
                titanic[titanic["age"] < 1]["age"] = 1
            \end{verbatim}
            
            \noindent La tabla no será cambiada, y se mostrará una advertencia. Cuando se ejecuta \texttt{titanic[titanic["age"] < 1]["age"]}, se está realizando dos operaciones de indexación consecutivas. Primero, \texttt{titanic[titanic["age"] < 1]} crea una vista o una copia temporal filtrada del \texttt{DataFrame titanic}, seleccionando solo las filas donde \texttt{age} es menor que 1. Luego, \texttt{["age"]} selecciona la columna \texttt{age} de esta vista o copia temporal. Al intentar asignar un nuevo valor a esta selección, se está modificando la copia temporal y no la tabla original.

            \noindent Pero, si se realiza una selección de la columna primero, y luego se realiza el filtro,
            \begin{verbatim}
                titanic["age"][titanic["age"] < 1] = 1
            \end{verbatim}

            La tabla sí será modificada. Esto es debido a la forma en que se realiza la indexación y asignación en este caso específico. En Pandas, cuando se hace una indexación directa sobre una columna del \texttt{DataFrame}, como en \texttt{titanic["age"]}, se obtiene una vista directa de esa columna en el \texttt{DataFrame} original, no una copia. Esta vista es una referencia a los datos en la columna \texttt{age} dentro del \texttt{DataFrame titanic}. Luego, cuando se aplica un filtro adicional con \texttt{[titanic["age"] < 1]}, se está seleccionando ciertas posiciones de esa vista, y cualquier cambio que hagas aquí se reflejará en el \texttt{DataFrame} original. Al asignar \texttt{= 1} a esta selección, se está modificando directamente los datos en la columna \texttt{age} del \texttt{DataFrame titanic}. Es importante notar que, aunque esta forma de indexación y asignación puede funcionar, no es la recomendada, ya que puede llevar a confusión y a errores sutiles, especialmente en contextos más complejos. \\\

            \noindent En conclusión, es importante tener claridad sobre cuándo se está realizando una vista de un conjunto de datos tomados de una tabla (apuntador a la columna, o conjunto de datos) y cuándo se está realizando una copia (sea temporal o no) de los datos; la copia es un objeto completamente independiente de la tabla original. Si se selecciona una columna mediante la notación de atributo (\texttt{titanic.age}) o mediante la notación de paréntesis cuadrados, o cualquier otra notación, es fácil y muy útil utilizar el atributo \texttt{\_is\_view} y el método \texttt{\_is\_copy()}.

            \subsubsection{Consejos de buena práctica:} 
                En general, según el propósito que se tenga, es conveniente y recomendado utilizar cierto tipo de métodos y atributos a la hora de manipular datos de una tabla.
                Si se requiere trabajar y manipular la tabla entera, entones el consejo es evitar el indexado encadenado. La indexación encadenada en Pandas se refiere al proceso de realizar varias operaciones de indexación sucesivas, una tras otra, típicamente utilizando corchetes \texttt{[]}. Esto suele verse en la forma de \texttt{dataframe[...][...]}, donde se realizan dos (o más) operaciones de indexación de forma secuencial. Por su parte, si se desea trabajar con porciones de la tabla, es recomendado realizar una copia de dicha porción mediante el método \texttt{copy()} y trabajar sobre esta.

        \subsection{Métodos de ordenamiento}

            \noindent La manera clásica de ordenar una tabla basado en una columna es la siguiente
            \begin{verbatim}
                titanic.sort_values(by = "age")
            \end{verbatim}
            Recordar que la línea anterior retorna la tabla ordenada, no modifica la actual, para hacer esto se debe usar el parámetro \texttt{inplace}. Recordar también el parámetro \texttt{ascending}.

            \noindent Se puede hacer ordenamiento no solamente por una columna sino por varias, pasando la lista con las etiquetas de las columnas como argumento del parámetro \texttt{by}. La columna de la primera etiqueta de la lista que se pasa como argumento es la que tiene la primera prioridad. También se puede pasar una lista booleana especificando cuáles se ordenarán de forma ascendente y cuáles descendente.
            \begin{verbatim}
                titanic.sort_values(by = ["col1", "col2", "col3"], ascending = [True False False], inplace = True)
            \end{verbatim}
            \noindent Siempre se puede reordenar la tabla con base en el índice de las filas:
            \begin{verbatim}
                titanic.sort_index(ascending = True, inplace = True)
            \end{verbatim}
            Cuando se realiza un ordenamiento basado en una columna, los índices también se ordenan o "desordenan". En algunas ocasionoes se requiere que el índice prevalezca ordenado aun cuando la tabla completa cambió con el ordenamiento. Esto se logra con dos formas distintas:
            \begin{verbatim}
                titanic.sort_values(by = age).reset_index(drop = True)
                titanc.sort_values(by = "age", ignore_index = True)
            \end{verbatim}

        \subsection{Estadísticas con agregación}

            El método \texttt{agg} es utilizado para realizar operaciones de agregación sobre una tabla, permitiendo aplicar una o más funciones sobre sus ejes. Se puede especificar una función, nombre de función, lista de funciones o un diccionario que mapea etiquetas de eje a funciones. Por defecto, estas operaciones se realizan sobre las filas (`axis=0`), pero también pueden aplicarse a las columnas (`axis=1`). El resultado de `agg` puede ser un escalar, una Serie o un DataFrame, dependiendo de la operación. Una forma efectiva de usarlo es seleccionar columnas de un tipo específico, como las numéricas, y luego aplicar un diccionario para realizar distintas operaciones en cada columna, tal como \texttt{df.select\_dtypes("number").agg({"col1": "mean", "col2": ["min", "std"]})}. Esto permite realizar análisis detallados y personalizados sobre los datos de manera eficiente.

        \subsection{Uso de funciones definidas en las tablas}

            \noindent Una funcionalidad interesante es la posibilidad de ejecutar funciones sobre todos los elementos de una tabla. Si definimos una función
            \begin{verbatim}
                def range(series):
                    return series.max() - series.min()
            \end{verbatim}
            \noindent Al implementar el método \texttt{apply} se puede ejecutar la función para los elementos de la columna o los elementos de las filas, según se establezca:
            \begin{verbatim}
                sales.apply(range, axis = 0)
            \end{verbatim}
            El valor de \texttt{axis = 0} es para las filas y \texttt{axis=1} para las columnas. Retornará una tabla con el resultado de la función. \\
            \noindent Se puede pasar la función lambda directamente en caso de requerir poco cóidigo:
            \begin{verbatim}
                sales.apply(lambda x: x.max() - x.min(), axis = 0)
            \end{verbatim}
            Si se selecciona una sola columna o porción de ella, el intérprete ya sabe que se ejecutará la función a dichos elementos:
            \begin{verbatim}
                sales.loc[1:10,"col1"].apply(lambda x: x[0])
            \end{verbatim}
            \noindent El método \texttt{map} es similar, con la diferencia de que solamente aplica para series de datos, es decir una columna por ejemplo. Por último, Se puede aplicar una función a toda la tabla (o parte de ella) mediante el siguiente método.
            \begin{verbatim}
                df.applymap(func)
                df.loc[1:99,"col"].applymap(func)
            \end{verbatim}

        \subsection{Multiindexación}
            En una tabla es posible que como índice, no solamente haya una columna, sino más de una:
            \begin{verbatim}
                df.set_index(["col1", "col2 "])
            \end{verbatim}
            Podemos ordenar de forma personalizada los diferentes índices:
            \begin{verbatim}
                df.sort__index(ascending = [True False])
            \end{verbatim}
            Como podemos ver, hay un índices exterior y uno interior, este orden puede ser cambiado mediante el método:
            \begin{verbatim}
                df.swaplevel()
            \end{verbatim}
            Se puede restablecer el índice de la siguiente forma:
            \begin{verbatim}
                df.reset_index(inplace = True)
            \end{verbatim}
            El indexador \texttt{loc} puede ser usado de la siguiente manera para poder extraer o filtrar información necesaria de una tabla:
            si se desea filtrar ambos índices y luego ver una columna, los índices deben ser puestos en una tupla:
            \begin{verbatim}
                df.loc[(idx1,idx2), col]
            \end{verbatim}
            Se puede no colocar ninguna columna y así veremos todas las columnas.
            Para seleccionar más de un valor para los índices, estos e colocan dentro de una lista. Para extraer todas las columnas, es necesario indicar los dos puntos:
            \begin{verbatim}
                df.loc[([idx1a,idx1b],idx2), col]
                df.loc[([idx1a,idx1b],idx2),:]
            \end{verbatim}
            Para seleccionar todos los valores de un índice, la notación \texttt{:} poroduce un error, por tanto se debe usar \texttt{slice(None)}:
            \begin{verbatim}
                df.loc[([idx1a,idx1b],slice(None)),:]
            \end{verbatim}

            \subsubsection{Operaciones con cadenas de texto}
                Para todos los datos dentro de una tabla que sean cadenas de texto, si se requiere realizar cualquier operación, se debe implementar el método \texttt{.str}:
                \begin{verbatim}
                    df.str.lower()
                \end{verbatim}
                Para el método \texttt{split}, se tiene la opción de separar de manera automática el resultado en columnas separadas:
                \begin{verbatim}
                    summer[col].srt.split("," n = 2, expand = True)
                \end{verbatim}
                El parámeto \texttt{n} indica cuántos de los caracteres separadores se requiere tomar, y el parámetro \texttt{expand} indica si se requiere guardar el retorno en columnas separadas. \\
                También es útil utilizar métodos de string como \texttt{contains} para realizar filtros personalizados y especializados:
                \begin{verbatim}
                    summer[summer["Event"].str.contains("100M")]
                \end{verbatim}

        \subsection{Limpieza de los datos}

            En el contexto de la limpieza de datos con Pandas, los métodos \texttt{df.col.replace()} y \texttt{DataFrame.rename(columns=...)} son herramientas esenciales. Estos métodos son utilizados para modificar el contenido y la estructura de los DataFrames, lo que facilita el análisis y procesamiento de los datos. Además, métodos como \texttt{DataFrame.info()}, \texttt{pd.Series.unique()} y \texttt{pd.Series.value\_counts()} juegan un papel importante en la verificación y exploración de los datos, lo cual es crucial para una gestión efectiva de los mismos.

            Por su parte el método \texttt{pd.DataFrame.rename(columns=...)} se utiliza para cambiar los nombres de las columnas de un \texttt{DataFrame}. La sintaxis es:
            \begin{verbatim}
            DataFrame.rename(columns = {'old_name' : 'new_name', ...}, inplace = False)
            \end{verbatim}
            donde \{\texttt{'old\_name'}: \texttt{'new\_name'}, \ldots\} es un diccionario que mapea los nombres actuales de las columnas a sus nuevos nombres, y \texttt{inplace=False} determina si el cambio se aplica directamente al \texttt{DataFrame} existente. Este método es fundamental para mantener la claridad y coherencia en la estructura de los datos.

            Para las columnas cuyos valores son \texttt{str}, se pueden hacer modificaciones a partir de \texttt{df.col.str}, por ejemplo, para una columna de valores con \texttt{"\$200"}, vemos que es una cadena de texto, y que se puede eliminar el caracter '\$'. de la siguiente manera

            \begin{verbatim}
                titanic.fare.str.replace('$', '')
            \end{verbatim}

            Luego de eso, ya es posible la conversión de valores de string a numérico.
            
            \begin{verbatim}
                titanic["fare"] = titnic.fare.astype('float')
            \end{verbatim}

            Es muy importante saber identificar los valores nulos de la tabla, con una combicación adecuada de los métodos \texttt{info}, \texttt{describe} y \texttt{value\_counts}, ademas de \texttt{dataframe.isna()}, el cual retona toda la tabla con los valores de verdad para cada valor.

            El método contrario \texttt{dataframe.notna()} también puede ser útil, en conjunto con la visualización de \texttt{seaborn}:

            \begin{verbatim}
                plt.figure(figsize = (12,8))
                seaborn.heatmap(titanic.notna())
                plt.show()
            \end{verbatim}

            Una forma rápida de eliminar todas las filas que tengan algún valor \texttt{None} es \texttt{df.dropna()}. Esto puede ser peligroso ya que en función de cada conjunto de datos se puede eliminar mnucha información importante. Se puede implementar con elparámetro \texttt{thresh}; este parámetro toma un valor entero que indica la cantidad mínima de valores no NaN que debe contener una fila o columna para ser conservada. Es decir, si el número de valores no NaN en una fila o columna es menor que el valor establecido en thresh, entonces esa fila o columna se eliminará del DataFrame. Se pueden defini subconjntos para eliminar filas con un numero suficientemente gande de valores faltantes:

            \begin{verbatim}
                titanic.dropna(axis=0, subset=["survived","class","gender","age"], thresh=4)
            \end{verbatim}

            En este ejemplo, se conservarán todas las filan que contengan menos de 4 o más valores válidos (no nulos) para el conjunto dado, y se eliminarán las demás. Como el conjunto dado son precisamente 4 columnas, entonces se eliminarán todas las filas con tengan al menos un valor nulo. 

            Por su parte, en algunas ocasiones es deseable no borrar las filas con alores nulos, sino reemplazarlos por un valor que puede ser la media o mediana para datos numéricos, esto se logra mediante:

            \begin{verbatim}
                titanic.age.fillna(mean, incplace = True)
            \end{verbatim}

            \subsubsection{Valores duplicados}

                Mediante el método \texttt{df.duplicate()} aplicado a una columna, se retorna una columna con valores de verdad para cada fila. 

                \begin{verbatim}
                    df.duplicate(keep = False)
                \end{verbatim}
                
                El parámetro \texttt{keep = False} indica que se marcarán como verdaderos todas las ocurrencias de los repetidos. Es importante tener en cuenta muchas característicse a la hora de identificar filas duplicadas. Según el tipo de conjunto de datos, dos entradas pueden tener exactamente los mismos valores, pero pertenecer a dos datos disntitos, es decir, no están realmente duplicados. 

            \subsubsection{Dato categóricos}

                En varias oasiones podemos identificar que es más adecuado redefinir una columna con un tipo de dato categórico, por ejemplo, género, color, etc.

                \begin{verbatim}
                    titanic.gencer = titanic.gender.astype("category")
                \end{verbatim}

    \section{Objeto \texttt{DataFrame}}

        Es una de las clases más importantes de Pandas; una estructura de datos tabular de dos dimensiones. Es una representación en Pandas de una tabla de datos.

        \subsection{Constructor} El constructor es el siguiente

        \begin{verbatim}
            class pandas.DataFrame(data=None, index=None, columns=None, dtype=None, copy=None)
        \end{verbatim}
        \subsubsection{Parámetros}

        \paragraph{\texttt{data}}
        \begin{itemize}
            \item \textbf{Descripción:} Es el conjunto de datos que conformará el DataFrame.
            \item \textbf{Tipo:} \texttt{numpy.ndarray}, elementos iterables, \texttt{dict}, o \texttt{DataFrame}
            \item \textbf{Por defecto:} \texttt{None}
        \end{itemize}

        \paragraph{\texttt{index}}
        \begin{itemize}
            \item \textbf{Descripción:} Es el comjunto de etiquetas de las filas de la estructura
            \item     \textbf{Tipo:} \texttt{Index} o arreglo de índices (una lista de \texttt{str}).
            \item     \textbf{Por defecto:} \texttt{None}
        \end{itemize}

        \paragraph{\texttt{columns}}
        \begin{itemize}
            \item \textbf{Descripción:} Es el conjunto de etiquetas de las columnas de la estructura
            \item \textbf{Tipo:} \texttt{Index} o arreglo de índices (lista de \texttt{str}).
            \item \textbf{Por defecto:} \texttt{None}.
        \end{itemize}

        \subsection{Atributos}

        La siguiente es la lista de los atributos de la clase \texttt{DataFrame}

        \subsubsection{~\hspace{2em} \texttt{T}:} La transposición del DataFrame.

        \subsubsection{~\hspace{2em}\texttt{at}:} Accede a un valor único para un par etiqueta de fila/columna.

        \subsubsection{~\hspace{2em}\texttt{attrs}:} Diccionario de atributos globales de este conjunto de datos.

        \subsubsection{~\hspace{2em}\texttt{axes}:} Devuelve una lista que representa los ejes del DataFrame (lista de \texttt{Index}).

        \subsubsection{~\hspace{2em}\texttt{columns[]}:} Las etiquetas de columna del DataFrame. Pueden indexarse como una lista.

        \subsubsection{~\hspace{2em}\texttt{dtypes}:} Devuelve los tipos de datos en el DataFrame.

        \subsubsection{~\hspace{2em}\texttt{empty}:} Indicador de si la Serie/DataFrame está vacío.

        \subsubsection{~\hspace{2em}\texttt{flags}:} Obtiene las propiedades asociadas con este objeto pandas.

        \subsubsection{~\hspace{2em}\texttt{iat}:} Accede a un valor único para un par fila/columna por posición entera.

        \subsubsection{~\hspace{2em}\texttt{iloc}:} Indexación basada puramente en la ubicación por posición entera.

        \subsubsection{~\hspace{2em}\texttt{index[]}:} El índice (etiquetas de fila) del DataFrame. Puede indexarse como en una lista.

        \subsubsection{~\hspace{2em}\texttt{loc}:} Accede a un grupo de filas y columnas por etiqueta(s) o un array booleano.

        \subsubsection{~\hspace{2em}\texttt{ndim}:} Devuelve un entero que representa el número de ejes / dimensiones del array.

        \subsubsection{~\hspace{2em}\texttt{shape}:} Devuelve una tupla que representa la dimensionalidad del DataFrame.

        \subsubsection{~\hspace{2em}\texttt{size}:} Devuelve un entero que representa el número de elementos en este objeto.

        \subsubsection{~\hspace{2em}\texttt{style}:} Devuelve un objeto Styler.

        \subsubsection{~\hspace{2em}\texttt{values}:} Devuelve una representación en Numpy del DataFrame.


        \begin{enumerate}
            \item\texttt{pd.options.display.min\_rows}
            \item\texttt{pd.options.display.max\_rows}
        \end{enumerate}
        Estas variables se modifican a conveniencia para mostrar una cantidad mínima y máxima requerida de los datos de la tabla.

        \subsection{Métodos}
        % \paragraph{\texttt{method1}} descripción
        % \subparagraph{\textbf{parámetros}}
        %     \begin{itemize}
        %         \item \texttt{param1}
        %             \begin{itemize}
        %                 \item \textbf{Descripción:}
        %                 \item \textbf{Tipo:}
        %                 \item \textbf{Por defecto:}
        %             \end{itemize}
        %     \end{itemize}

        % \subparagraph{\textbf{Tipo de retorno:}}

        \subsubsection{\texttt{abs()}} Devuelve una Serie/DataFrame con el valor numérico absoluto de cada elemento.
        \paragraph{\textbf{parámetros}}
        \begin{itemize}
            \item \texttt{Ninguno}
        \end{itemize}
        \subparagraph{\textbf{Retorno:}} \texttt{pandas.Series} o \texttt{Pandas.DataaFrame}

        \subsubsection{\texttt{add(other, axis, level, fill\_value)}} Obtiene la suma de los elementos (elemento a elemento) del dataframe con otro dataframe (u objeto similar).
        \paragraph{\textbf{parámetros}}
        \begin{itemize}
            \item \texttt{other}
                \begin{itemize}
                    \item \textbf{Descripción:} Objeto con el cual se realiza la suma.
                    \item \textbf{Tipo:} \texttt{Serie}, \texttt{DataFrame}, \texttt{dict} o cualquier escalar o secuencia.
                    \item \textbf{Por defecto:} Ninguno
                \end{itemize}
            \item \texttt{axis}
                \begin{itemize}
                    \item \textbf{Descripción:} Selecciona si comparar por el índice o por la columna.
                    \item \textbf{Tipo:} \texttt{0} o \texttt{'index'}, \texttt{1} o \texttt{'column'}
                    \item \textbf{Por defecto:} \texttt{'columns'}
                \end{itemize}
            \item \texttt{fill\_value}
                \begin{itemize}
                    \item \textbf{Descripción:} Rellenar valores que potencialmente serán no determinados (\texttt{NaN}). Esto es especialmente útil cuando se usan dos tablas con diferentes índices y/o columnas.
                    \item \textbf{Tipo:} \texttt{float} o \texttt{None}
                    \item \textbf{Por defecto:} \texttt{None}
                \end{itemize}
        \end{itemize}
        \paragraph{Retorno:} \texttt{DataFrame} con los resultados de los valores





        \subsubsection{\texttt{add\_prefix(prefix, axis)}} Añade un prefijo a las columnas. Si la columna es \texttt{'a'} y el prefijo dado es \texttt{'col\_'}, la columna queda etiquetada como \texttt{col\_a}. No modifica el objeto (retorna uno nuevo)
        \paragraph{\textbf{parámetros}}
        \begin{itemize}
            \item \texttt{prefix}
                \begin{itemize}
                    \item \textbf{Descripción:} La cadena de texto para prefijar.
                    \item \textbf{Tipo:} \texttt{String}
                    \item \textbf{Por defecto:} Ninguno
                \end{itemize}
            \item \texttt{axis}
                \begin{itemize}
                    \item \textbf{Descripción:} Selecciona el eje al cual añadir el prefijo.
                    \item \textbf{Tipo:}  \texttt{0} o \texttt{'index'}, \texttt{1} o \texttt{'column'}
                    \item \textbf{Por defecto:} \texttt{None}
                \end{itemize}
        \end{itemize}
        \paragraph{Retorno:} \texttt{DataFrame}


        \subsubsection{\texttt{add\_suffix(suffix, axis)}} Añade un sufijo a las columnas. Análogo al método anterior.
        \paragraph{\textbf{parámetros}}
        \begin{itemize}
            \item \texttt{suffix}
                \begin{itemize}
                    \item \textbf{Descripción:} La cadena de texto a añadir.
                    \item \textbf{Tipo:} \texttt{String}
                    \item \textbf{Por defecto:} Ninguno
                \end{itemize}
            \item \texttt{axis}
                \begin{itemize}
                    \item \textbf{Descripción:} Selecciona el eje al cual añadir el sufijo.
                    \item \textbf{Tipo:} \texttt{0} o \texttt{'index'}, \texttt{1} o \texttt{'column'}
                    \item \textbf{Por defecto:} \texttt{None}
                \end{itemize}
        \end{itemize}
        \paragraph{Retorno:} \texttt{DataFrame}


        \subsubsection{\texttt{agg(func, axis)}} Agrega utilizando una o más operaciones sobre el eje especificado.
        \paragraph{\textbf{parámetros}}
        \begin{itemize}
            \item \texttt{func}
                \begin{itemize}
                    \item \textbf{Descripción:} La función o funciones para aplicar.
                    \item \textbf{Tipo:} Función o lista de funciones (como ejemplo \texttt{'sum'})
                    \item \textbf{Por defecto:} Ninguno
                \end{itemize}
            \item \texttt{axis}
                \begin{itemize}
                    \item \textbf{Descripción:} Eje sobre la cual realizar la función, si esta última está definida para listas.
                    \item \textbf{Tipo:} \texttt{0} o \texttt{'index'}, \texttt{1} o \texttt{'column'}
                    \item \textbf{Por defecto:} \texttt{0}
                \end{itemize}
        \end{itemize}
        \paragraph{Retorno:} \texttt{DataFrame}, \texttt{Series} o puede ser escalar, dependiendo de la función usada.


        \subsubsection{\texttt{align(other, join, axis, level, copy, fill\_value)}}
        Alinea dos objetos en sus ejes con el método de unión especificado. El método de unión está especificado para cada índice de eje.

        \paragraph{\textbf{Parámetros}}
        \begin{itemize}
            \item \texttt{other}
                \begin{itemize}
                    \item \textbf{Descripción:} DataFrame o Series con el que se quiere alinear.
                    \item \textbf{Tipo:} DataFrame o Series
                    \item \textbf{Por defecto:} Ninguno
                \end{itemize}
            \item \texttt{join}
                \begin{itemize}
                    \item \textbf{Descripción:} Tipo de alineación a realizar (\texttt{'outer'}, \texttt{'inner'}, \texttt{'left'}, \texttt{'right'}).
                    \item \textbf{Tipo:} Cadena de texto
                    \item \textbf{Por defecto:} \texttt{'outer'}
                \end{itemize}
            \item \texttt{axis}
                \begin{itemize}
                    \item \textbf{Descripción:} Eje permitido del otro objeto.
                    \item \textbf{Tipo:} \texttt{0}, \texttt{1}, o \texttt{None}
                    \item \textbf{Por defecto:} \texttt{None}
                \end{itemize}
            \item \texttt{level}
                \begin{itemize}
                    \item \textbf{Descripción:} Difunde a través de un nivel, coincidiendo con los valores del índice en el nivel MultiIndex pasado.
                    \item \textbf{Tipo:} Entero o nombre de nivel
                    \item \textbf{Por defecto:} \texttt{None}
                \end{itemize}
            \item \texttt{copy}
                \begin{itemize}
                    \item \textbf{Descripción:} Siempre devuelve nuevos objetos. Si \texttt{copy=False} y no se requiere reindexación, se devuelven los objetos originales.
                    \item \textbf{Tipo:} Booleano
                    \item \textbf{Por defecto:} \texttt{True}
                \end{itemize}
            \item \texttt{fill\_value}
                \begin{itemize}
                    \item \textbf{Descripción:} Valor a utilizar para valores faltantes. Por defecto es NaN, pero puede ser cualquier valor "compatible".
                    \item \textbf{Tipo:} Escalar
                    \item \textbf{Por defecto:} \texttt{np.nan}
                \end{itemize}
        \end{itemize}

        \paragraph{Retorno:} Tupla de (Series/DataFrame, tipo del otro objeto)
        \begin{itemize}
            \item \textbf{Descripción:} Objetos alineados.
            \item \textbf{Tipo:} Tupla
        \end{itemize}


        \subsubsection{\texttt{all(axis, bool\_only, skipna, **kwargs)}}
        Devuelve si todos los elementos son \texttt{True}, potencialmente a lo largo de un eje. Devuelve \texttt{True} a menos que haya al menos un elemento dentro de una serie o a lo largo de un eje de DataFrame que sea \texttt{False} o equivalente (p. ej., cero o vacío).

        \paragraph{\textbf{Parámetros}}
        \begin{itemize}
            \item \texttt{axis}
                \begin{itemize}
                    \item \textbf{Descripción:} Indica qué eje o ejes deben reducirse. Para Series, este parámetro no se utiliza y se establece en 0 por defecto.
                    \item \textbf{Tipo:} \texttt{0} o \texttt{'index'}, \texttt{1} o \texttt{'columns'}, \texttt{None}
                    \item \textbf{Por defecto:} \texttt{0}
                \end{itemize}
            \item \texttt{bool\_only}
                \begin{itemize}
                    \item \textbf{Descripción:} Incluye solo columnas booleanas. No implementado para Series.
                    \item \textbf{Tipo:} Booleano
                    \item \textbf{Por defecto:} \texttt{False}
                \end{itemize}
            \item \texttt{skipna}
                \begin{itemize}
                    \item \textbf{Descripción:} Excluye valores NA/nulos. Si toda la fila/columna es NA y \texttt{skipna} es \texttt{True}, entonces el resultado será \texttt{True}, como en el caso de una fila/columna vacía. Si \texttt{skipna} es \texttt{False}, entonces los NA se tratan como \texttt{True}, porque no son iguales a cero.
                    \item \textbf{Tipo:} Booleano
                    \item \textbf{Por defecto:} \texttt{True}
                \end{itemize}
            \item \texttt{**kwargs}
                \begin{itemize}
                    \item \textbf{Descripción:} Palabras clave adicionales no tienen efecto pero podrían ser aceptadas para compatibilidad con NumPy.
                    \item \textbf{Tipo:} Cualquiera
                    \item \textbf{Por defecto:} \texttt{None}
                \end{itemize}
        \end{itemize}

        \paragraph{Retorno:} Series o DataFrame
        \begin{itemize}
            \item \textbf{Descripción:} Si se especifica un nivel, se devuelve un DataFrame; de lo contrario, se devuelve una Series.
            \item \textbf{Tipo:} Series o DataFrame
        \end{itemize}



        \subsubsection{\texttt{DataFrame.any(*, axis=0, bool\_only=False, skipna=True, **kwargs)}}
        Devuelve si algún elemento es \texttt{True}, potencialmente a lo largo de un eje. Devuelve \texttt{False} a menos que haya al menos un elemento dentro de una serie o a lo largo de un eje de DataFrame que sea \texttt{True} o equivalente (p.ej., no cero o no vacío).

        \paragraph{\textbf{Parámetros}}
        \begin{itemize}
            \item \texttt{axis}
                \begin{itemize}
                    \item \textbf{Descripción:} Indica qué eje o ejes deben reducirse. Para Series, este parámetro no se utiliza y se establece en 0 por defecto.
                    \item \textbf{Tipo:} \texttt{0} o \texttt{'index'}, \texttt{1} o \texttt{'columns'}, \texttt{None}
                    \item \textbf{Por defecto:} \texttt{0}
                \end{itemize}
            \item \texttt{bool\_only}
                \begin{itemize}
                    \item \textbf{Descripción:} Incluye solo columnas booleanas. No implementado para Series.
                    \item \textbf{Tipo:} Booleano
                    \item \textbf{Por defecto:} \texttt{False}
                \end{itemize}
            \item \texttt{skipna}
                \begin{itemize}
                    \item \textbf{Descripción:} Excluye valores NA/nulos. Si toda la fila/columna es NA y \texttt{skipna} es \texttt{True}, entonces el resultado será \texttt{False}, como en el caso de una fila/columna vacía. Si \texttt{skipna} es \texttt{False}, entonces los NA se tratan como \texttt{True}, porque no son iguales a cero.
                    \item \textbf{Tipo:} Booleano
                    \item \textbf{Por defecto:} \texttt{True}
                \end{itemize}
            \item \texttt{**kwargs}
                \begin{itemize}
                    \item \textbf{Descripción:} Palabras clave adicionales no tienen efecto pero podrían ser aceptadas para compatibilidad con NumPy.
                    \item \textbf{Tipo:} Cualquiera
                    \item \textbf{Por defecto:} \texttt{None}
                \end{itemize}
        \end{itemize}

        \paragraph{Retorno:} Series o DataFrame
        \begin{itemize}
            \item \textbf{Descripción:} Si se especifica un nivel, se devuelve un DataFrame; de lo contrario, se devuelve una Series.
            \item \textbf{Tipo:} Series o DataFrame
        \end{itemize}






        \subsubsection{\texttt{head(n)}} Esta función retorna las primeras \( n \) filas del objeto basado en su posición. Es útil para comprobar rápidamente si el objeto contiene el tipo correcto de datos.

        Para valores negativos de \( n \), esta función devuelve todas las filas excepto las últimas \( |n| \) filas, equivalente a \( \text{df}[:n] \).

        Si \( n \) es mayor que el número de filas, esta función retorna todas las filas.

        \paragraph{\textbf{Parámetros}}
        \begin{itemize}
            \item \texttt{n}
                \begin{itemize}
                    \item \textbf{Descripción:} Número de filas a seleccionar.
                    \item \textbf{Tipo:} Entero
                    \item \textbf{Por defecto:} 5
                \end{itemize}
        \end{itemize}

        \paragraph{Retorno:} Mismo tipo que el objeto que llama
        \begin{itemize}
            \item \textbf{Descripción:} Las primeras \( n \) filas del objeto que llama la función.
            \item \textbf{Tipo:} Mismo tipo que el objeto que llama
        \end{itemize}


        \paragraph{Tipo de dato de salida} \texttt{DataFrame}

        \subsubsection{\texttt{tail(n=5)}} Esta función retorna las últimas \( n \) filas del objeto basado en su posición. Es útil para verificar rápidamente los datos, por ejemplo, después de ordenar o agregar filas.

        Para valores negativos de \( n \), esta función devuelve todas las filas excepto las primeras \( |n| \) filas, equivalente a \( \text{df}[|n|:] \).

        Si \( n \) es mayor que el número de filas, esta función retorna todas las filas.

        \paragraph{\textbf{Parámetros}}
        \begin{itemize}
            \item \texttt{n}
                \begin{itemize}
                    \item \textbf{Descripción:} Número de filas a seleccionar.
                    \item \textbf{Tipo:} Entero
                    \item \textbf{Por defecto:} 5
                \end{itemize}
        \end{itemize}

        \paragraph{Retorno:} Tipo del objeto que llama la función
        \begin{itemize}
            \item \textbf{Descripción:} Las últimas \( n \) filas del objeto que llama la función.
            \item \textbf{Tipo:} Tipo del objeto que llama la función
        \end{itemize}



        \subsubsection{\texttt{info(verbose, buf, max\_cols, memory\_usage, show\_counts)}} Este método imprime información sobre un DataFrame incluyendo el tipo de datos del índice y las columnas, los valores no nulos y el uso de memoria.

        \paragraph{\textbf{Parámetros}}
        \begin{itemize}
            \item \texttt{verbose}
                \begin{itemize}
                    \item \textbf{Descripción:} Si se imprime el resumen completo. Por defecto, se sigue la configuración en \texttt{pandas.options.display.max\_info\_columns}.
                    \item \textbf{Tipo:} Booleano, opcional
                \end{itemize}
            \item \texttt{buf}
                \begin{itemize}
                    \item \textbf{Descripción:} Dónde enviar la salida. Por defecto, la salida se imprime en \texttt{sys.stdout}. Se puede pasar un búfer escribible si se necesita procesar más la salida.
                    \item \textbf{Tipo:} Búfer escribible, valor por defecto \texttt{sys.stdout}
                \end{itemize}
            \item \texttt{max\_cols}
                \begin{itemize}
                    \item \textbf{Descripción:} Cuándo cambiar de la salida detallada a la salida truncada. Si el DataFrame tiene más de \texttt{max\_cols} columnas, se utiliza la salida truncada.
                    \item \textbf{Tipo:} Entero, opcional
                \end{itemize}
            \item \texttt{memory\_usage}
                \begin{itemize}
                    \item \textbf{Descripción:} Especifica si se debe mostrar el uso total de memoria de los elementos del DataFrame (incluido el índice).
                    \item \textbf{Tipo:} Booleano, cadena, opcional
                \end{itemize}
            \item \texttt{show\_counts}
                \begin{itemize}
                    \item \textbf{Descripción:} Si se muestran los recuentos de no nulos. Por defecto, esto se muestra solo si el DataFrame es más pequeño que las opciones en \texttt{pandas.options.display.max\_info\_rows} y \texttt{pandas.options.display.max\_info\_columns}.
                    \item \textbf{Tipo:} Booleano, opcional
                \end{itemize}
        \end{itemize}

        \paragraph{Retorno:} Ninguno
        \begin{itemize}
            \item \textbf{Descripción:} Este método imprime un resumen de un DataFrame y no devuelve nada.
            \item \textbf{Tipo:} Ninguno
        \end{itemize}


        \subsubsection{\texttt{describe(percentiles, include, exclude)}}Genera estadísticas descriptivas. Las estadísticas descriptivas incluyen aquellas que resumen la tendencia central, la dispersión y la forma de la distribución del conjunto de datos, excluyendo los valores NaN. Analiza tanto series numéricas como de objeto, así como conjuntos de columnas de DataFrame de tipos de datos mixtos. La salida variará dependiendo de lo que se proporcione. Consulte las notas a continuación para obtener más detalles.

        \paragraph{\textbf{Parámetros}}
        \begin{itemize}
            \item \texttt{percentiles}
                \begin{itemize}
                    \item \textbf{Descripción:} Los percentiles a incluir en la salida. Todos deben estar entre 0 y 1. El valor por defecto es \([.25, .5, .75]\), que devuelve los percentiles 25, 50 y 75.
                    \item \textbf{Tipo:} Lista de números
                    \item \textbf{Por defecto:} Ninguno (Opcional)
                \end{itemize}
            \item \texttt{include}
                \begin{itemize}
                    \item \textbf{Descripción:} Lista blanca de tipos de datos para incluir en el resultado. Ignorado para Series.
                    \item \textbf{Tipo:} ‘all’, lista de tipos de datos o Ninguno (Por defecto)
                    \item \textbf{Opciones:} ‘all’, lista de dtypes, Ninguno
                \end{itemize}
            \item \texttt{exclude}
                \begin{itemize}
                    \item \textbf{Descripción:} Lista negra de tipos de datos para omitir del resultado. Ignorado para Series.
                    \item \textbf{Tipo:} Lista de tipos de datos o Ninguno (Por defecto)
                    \item \textbf{Opciones:} Lista de dtypes, Ninguno
                \end{itemize}
        \end{itemize}

        \paragraph{Retorno:} Series o DataFrame
        \begin{itemize}
            \item \textbf{Descripción:} Estadísticas resumidas de la Series o DataFrame proporcionado.
            \item \textbf{Tipo:} Series o DataFrame
        \end{itemize}


        \subsubsection{\texttt{len(df)}} Retorna el número de filas que hay en la tabla.
        \subparagraph{Tipo de dato de salida} \texttt{Int}


        \paragraph{\texttt{round(df,0)}} Retorna la tabla con los valores numéricos redondeados con las cifras especificadas.
        \paragraph{Tipo de dato de salida} \texttt{Int}


        \subsubsection{\texttt{mean(axis, skipna, numeric\_only, **kwargs)}} Calcula la media de los valores a lo largo del eje solicitado.

        \paragraph{\textbf{Parámetros}}
        \begin{itemize}
            \item \texttt{axis}
                \begin{itemize}
                    \item \textbf{Descripción:} Eje sobre el que se aplica la función. Para Series, este parámetro no se utiliza y su valor predeterminado es 0. Para DataFrames, especificar \texttt{axis=None} aplicará la agregación en ambos ejes.
                    \item \textbf{Tipo:} \{0 ('index'), 1 ('columns')\}
                    \item \textbf{Por defecto:} \texttt{0}
                \end{itemize}

            \item \texttt{skipna}
                \begin{itemize}
                    \item \textbf{Descripción:} Excluir valores NA/nulos al calcular el resultado.
                    \item \textbf{Tipo:} Booleano
                    \item \textbf{Por defecto:} \texttt{True}
                \end{itemize}

            \item \texttt{numeric\_only}
                \begin{itemize}
                    \item \textbf{Descripción:} Incluir solo columnas de tipo float, int, booleano. No implementado para Series.
                    \item \textbf{Tipo:} Booleano
                    \item \textbf{Por defecto:} \texttt{False}
                \end{itemize}

            \item \texttt{**kwargs}
                \begin{itemize}
                    \item \textbf{Descripción:} Argumentos de palabras clave adicionales para pasar a la función.
                    \item \textbf{Tipo:} Cualquiera
                \end{itemize}
        \end{itemize}

        \paragraph{Retorno:} Series o escalar
        \begin{itemize}
            \item \textbf{Descripción:} La media de los valores a lo largo del eje especificado.
            \item \textbf{Tipo:} \texttt{Series} o escalar
        \end{itemize}




        \subsubsection{\texttt{sort\_values(by, *, axis, ascending, inplace, kind, na\_position, ignore\_index, key)}} Ordena por los valores a lo largo de cualquiera de los ejes.

        \paragraph{\textbf{Parámetros}}
        \begin{itemize}
            \item \texttt{by}
                \begin{itemize}
                    \item \textbf{Descripción:} Nombre o lista de nombres (índices) por los que ordenar.
                    \item \textbf{Tipo:} Cadena de caracteres o lista de cadenas de caracteres, según el índice.
                \end{itemize}

            \item \texttt{axis}
                \begin{itemize}
                    \item \textbf{Descripción:} Eje que será ordenado.
                    \item \textbf{Tipo:} \{0 ('index'), 1 ('columns')\}
                    \item \textbf{Por defecto:} 0
                \end{itemize}

            \item \texttt{ascending}
                \begin{itemize}
                    \item \textbf{Descripción:} Ordenar de forma ascendente vs descendente. Especifique una lista para múltiples órdenes de clasificación.
                    \item \textbf{Tipo:} Booleano o lista de booleanos
                    \item \textbf{Por defecto:} Verdadero
                \end{itemize}

            \item \texttt{inplace}
                \begin{itemize}
                    \item \textbf{Descripción:} Si es Verdadero, aplica el ordenamiento al objeto.
                    \item \textbf{Tipo:} Booleano
                    \item \textbf{Por defecto:} Falso
                \end{itemize}

            \item \texttt{kind}
                \begin{itemize}
                    \item \textbf{Descripción:} Elección del algoritmo de ordenación.
                    \item \textbf{Tipo:} \{'quicksort', 'mergesort', 'heapsort', 'stable'\}
                    \item \textbf{Por defecto:} 'quicksort'
                \end{itemize}

            \item \texttt{na\_position}
                \begin{itemize}
                    \item \textbf{Descripción:} Ubica los NaN al principio si es 'first'; al final si es 'last'.
                    \item \textbf{Tipo:} \{'first', 'last'\}
                    \item \textbf{Por defecto:} 'last'
                \end{itemize}

            \item \texttt{ignore\_index}
                \begin{itemize}
                    \item \textbf{Descripción:} Si es Verdadero, el eje resultante se etiquetará 0, 1, ..., n - 1.
                    \item \textbf{Tipo:} Booleano
                    \item \textbf{Por defecto:} Falso
                \end{itemize}

            \item \texttt{key}
                \begin{itemize}
                    \item \textbf{Descripción:} Aplicar la función clave a los valores antes de ordenar.
                    \item \textbf{Tipo:} Función
                    \item \textbf{Opcional:} Verdadero
                \end{itemize}
        \end{itemize}

        \paragraph{Retorno:} DataFrame o None
        \begin{itemize}
            \item \textbf{Descripción:} DataFrame con valores ordenados o None si \texttt{inplace=True}.
            \item \textbf{Tipo:} DataFrame o None
        \end{itemize}


        \subsubsection{Selección de columnas}

        Si se tiene un DataFrame, podemos usar el índice \texttt{[]} para seleccionar una o más columnas diferentes.

        \begin{verbatim}
                            df["col1"]
                            \end{verbatim}
        Una forma alternativa es mediante la notación de punto:

        \begin{verbatim}
                            df.col1
                            \end{verbatim}
        Si queremos obtener más de una columna, debemos ingresar las etiquetas de dichas columnas como una \textbf{lista}:
        \begin{verbatim}
                            df[["col1","col2"]]
                            \end{verbatim}
        \paragraph{Tipo de dato de salida} Si se pone solamente la etiqueta de una columna como argumento, el tipo de retorno será \texttt{Series}. Si se pone una lista de una o más etiquetas, entonces la salida será otro \texttt{DataFrame}.

        \subsubsection{\texttt{df.iloc[n,m]}} Este método retorna la información de la fila enésima y columna enésima. Se pueden seleccionar una o más filas/columnas, y si se requiere un conjunto específico de filas/columnas, deben ingresarse dentro de una lista
        \begin{verbatim}
                            df.iloc[25:30]
                            df.iloc[25,2]
                            df.iloc[25:30,2:5]
                            df.iloc[[100,345,778],[0,4]]
                            \end{verbatim}
        \paragraph{Tipo de dato de salida} \texttt{Series, DataFrame} o el tipo de objeto en la celda, cuando se especifica una sola celda.

        \subsubsection{\texttt{df.loc[Rlabel,Clabel]}} Este método es muy similar al anterior, con la diferencia de que se asigna como argumento el texto de la etiqueta de la fila que se desea retornar. Si hay más de una fila con la misma etiqueta, entonces se retornan todas las filas.

        \paragraph{Tipo de dato de salida} \texttt{Series, DataFrame} o el tipo de objeto en la celda, cuando se especifica una sola celda.

        Si se intenta capturar los datos de varias filas hasta una etiqueta especificada (por ejemplo, \texttt{df.loc[:"Clabel"]} mostrará error si esta etiqueta no es única.


        En general se puede acceder a las filas o columnas de un conjunto de datos pensando en la entrada de indexación como listas. Si por ejemplo se requiere un rango específico de filas más unas filas específicas, se puede usar lo siguiente

        \begin{verbatim}
                                index = list(range(15,20)) + [35,45]
                                df.iloc[index]
                                \end{verbatim}
        O si se requieren, por ejemplo las tres primeras columnas, más dos columnas específicas más:
        \begin{verbatim}
                                col_index = df.columns[:3].tolist() + ["col7","col9"]
                                df.loc[:, col_index]
                                \end{verbatim}


        \subsubsection{\texttt{copy(deep)}} Realiza una copia de los índices y datos de este objeto.

        \paragraph{\textbf{Descripción}}
        Cuando \texttt{deep=True} (por defecto), se crea un nuevo objeto con una copia de los datos e índices del objeto que hace la llamada. Las modificaciones en los datos o índices de la copia no se reflejarán en el objeto original.

        Cuando \texttt{deep=False}, se crea un nuevo objeto sin copiar los datos o el índice del objeto que hace la llamada (sólo se copian las referencias a los datos y el índice). Cualquier cambio en los datos del original se reflejará en la copia superficial (y viceversa).

        \paragraph{\textbf{Parámetros}}
        \begin{itemize}
            \item \texttt{deep}
                \begin{itemize}
                    \item \textbf{Descripción:} Realizar una copia profunda, incluyendo una copia de los datos y los índices. Con \texttt{deep=False} ni los índices ni los datos se copian.
                    \item \textbf{Tipo:} Booleano
                    \item \textbf{Por defecto:} Verdadero
                \end{itemize}
        \end{itemize}

        \paragraph{\textbf{Retorno:} Series o DataFrame}
        \begin{itemize}
            \item \textbf{Descripción:} El tipo de objeto coincide con el que hace la llamada.
            \item \textbf{Tipo:} Series o DataFrame
        \end{itemize}


        \subsubsection{\texttt{nlargest(n, columns, keep)}} Devuelve las primeras \( n \) filas ordenadas por las columnas en orden descendente.

        \subparagraph{\textbf{Descripción}} Devuelve las primeras \( n \) filas con los valores más grandes en las columnas, en orden descendente. Las columnas que no se especifican también se devuelven, pero no se utilizan para ordenar. Este método es equivalente a \texttt{df.sort\_values(columns, ascending=False).head(n)}, pero es más eficiente en términos de rendimiento.

        \paragraph{\textbf{Parámetros}}
        \begin{itemize}
            \item \texttt{n}
                \begin{itemize}
                    \item \textbf{Descripción:} Número de filas a devolver.
                    \item \textbf{Tipo:} Entero
                \end{itemize}
            \item \texttt{columns}
                \begin{itemize}
                    \item \textbf{Descripción:} Etiqueta(s) de columna por las cuales ordenar.
                    \item \textbf{Tipo:} Etiqueta o lista de etiquetas
                \end{itemize}
            \item \texttt{keep}
                \begin{itemize}
                    \item \textbf{Descripción:} Donde hay valores duplicados:
                            \begin{itemize}
                                \item \texttt{first}: da prioridad a la primera ocurrencia(s).
                                \item \texttt{last}: da prioridad a la última ocurrencia(s).
                                \item \texttt{all}: no elimina ningún duplicado, incluso si eso significa seleccionar más de \( n \) elementos.
                            \end{itemize}
                    \item \textbf{Tipo:} \{`first', `last', `all'\}
                    \item \textbf{Por defecto:} `first'
                \end{itemize}
        \end{itemize}

        \paragraph{\textbf{Retorno:} DataFrame}
        \begin{itemize}
            \item \textbf{Descripción:} Las primeras \( n \) filas ordenadas por las columnas dadas en orden descendente.
            \item \textbf{Tipo:} DataFrame
        \end{itemize}


        \subsubsection{\texttt{nsmallest(n, columns, keep)}} Devuelve las primeras \( n \) filas ordenadas por las columnas en orden ascendente.

        \paragraph{\textbf{Descripción}}
        Devuelve las primeras \( n \) filas con los valores más pequeños en las columnas, en orden ascendente. Las columnas que no se especifican también se devuelven, pero no se utilizan para ordenar.

        Este método es equivalente a \texttt{df.sort\_values(columns, ascending=True).head(n)}, pero es más eficiente en términos de rendimiento.

        \paragraph{\textbf{Parámetros}}
        \begin{itemize}
            \item \texttt{n}
                \begin{itemize}
                    \item \textbf{Descripción:} Número de elementos a recuperar.
                    \item \textbf{Tipo:} Entero
                \end{itemize}
            \item \texttt{columns}
                \begin{itemize}
                    \item \textbf{Descripción:} Nombre o nombres de columna por los cuales ordenar.
                    \item \textbf{Tipo:} Lista o cadena de caracteres
                \end{itemize}
            \item \texttt{keep}
                \begin{itemize}
                    \item \textbf{Descripción:} Si hay valores duplicados:
                            \begin{itemize}
                                \item \texttt{first}: toma la primera ocurrencia.
                                \item \texttt{last}: toma la última ocurrencia.
                                \item \texttt{all}: no elimina ningún duplicado, incluso si eso significa seleccionar más de \( n \) elementos.
                            \end{itemize}
                    \item \textbf{Tipo:} \{`first', `last', `all'\}
                    \item \textbf{Por defecto:} `first'
                \end{itemize}
        \end{itemize}

        \paragraph{\textbf{Retorno:} DataFrame}
        \begin{itemize}
            \item \textbf{Descripción:} Las primeras \( n \) filas ordenadas por las columnas dadas en orden ascendente.
            \item \textbf{Tipo:} DataFrame
        \end{itemize}


        \subsubsection{\texttt{idxmin(axis, skipna, numeric\_only)}} Devuelve el índice de la primera ocurrencia del mínimo a lo largo del eje solicitado. Los valores NA/nulos son excluidos.

        \paragraph{\textbf{Descripción}}
        Esta función retorna el índice de la primera aparición del valor mínimo a lo largo del eje especificado, excluyendo los valores NA/nulos.

        \paragraph{\textbf{Parámetros}}
        \begin{itemize}
            \item \texttt{axis}
                \begin{itemize}
                    \item \textbf{Descripción:} El eje a utilizar. 0 o `index' para filas, 1 o `columns' para columnas.
                    \item \textbf{Tipo:} \{0 o `index', 1 o `columns'\}
                    \item \textbf{Por defecto:} 0
                \end{itemize}
            \item \texttt{skipna}
                \begin{itemize}
                    \item \textbf{Descripción:} Excluir valores NA/nulos. Si una fila/columna entera es NA, el resultado será NA.
                    \item \textbf{Tipo:} Booleano
                    \item \textbf{Por defecto:} Verdadero
                \end{itemize}
            \item \texttt{numeric\_only}
                \begin{itemize}
                    \item \textbf{Descripción:} Incluir solo datos de tipo flotante, entero o booleano.
                    \item \textbf{Tipo:} Booleano
                    \item \textbf{Por defecto:} Falso
                \end{itemize}
        \end{itemize}

        \paragraph{\textbf{Retorno:} Series}
        \begin{itemize}
            \item \textbf{Descripción:} Índices de los mínimos a lo largo del eje especificado.
            \item \textbf{Tipo:} Series
        \end{itemize}

        \paragraph{\textbf{Excepciones}}
        \begin{itemize}
            \item \texttt{ValueError}
                \begin{itemize}
                    \item \textbf{Descripción:} Se levanta si la fila o columna está vacía.
                \end{itemize}
        \end{itemize}

        \paragraph{\texttt{DataFrame.reset\_index}}

        \paragraph{Descripción:}
        Restablece el índice del DataFrame, y utiliza el índice predeterminado en su lugar.
        Si el DataFrame tiene un MultiIndex, este método puede eliminar uno o más niveles.

        \paragraph{Parámetros:}
        \begin{itemize}
            \item \texttt{level}
                \begin{itemize}
                    \item \textbf{Descripción:} Solo elimina los niveles dados del índice. Elimina todos los niveles por defecto.
                    \item \textbf{Tipo:} int, str, tuple, o list
                    \item \textbf{Por defecto:} \texttt{None}
                \end{itemize}

            \item \texttt{drop}
                \begin{itemize}
                    \item \textbf{Descripción:} Si se activa, quita completamente la columna de índices que estaba anteriormente, y la borra.
                    \item \textbf{Tipo:} bool
                    \item \textbf{Por defecto:} \texttt{False}
                \end{itemize}

            \item \texttt{inplace}
                \begin{itemize}
                    \item \textbf{Descripción:} Si se debe modificar el DataFrame en lugar de crear uno nuevo.
                    \item \textbf{Tipo:} bool
                    \item \textbf{Por defecto:} \texttt{False}
                \end{itemize}

            \item \texttt{col\_level}
                \begin{itemize}
                    \item \textbf{Descripción:} Si las columnas tienen múltiples niveles, determina en qué nivel se insertan las etiquetas. Por defecto, se insertan en el primer nivel.
                    \item \textbf{Tipo:} int o str
                    \item \textbf{Por defecto:} \texttt{0}
                \end{itemize}

            \item \texttt{col\_fill}
                \begin{itemize}
                    \item \textbf{Descripción:} Si las columnas tienen múltiples niveles, determina cómo se nombran los otros niveles.
                    \item \textbf{Tipo:} object
                    \item \textbf{Por defecto:} \texttt{''}
                \end{itemize}

            \item \texttt{allow\_duplicates}
                \begin{itemize}
                    \item \textbf{Descripción:} Permite la creación de etiquetas de columna duplicadas.
                    \item \textbf{Tipo:} bool, opcional
                    \item \textbf{Por defecto:} \texttt{lib.no\_default}
                \end{itemize}

            \item \texttt{names}
                \begin{itemize}
                    \item \textbf{Descripción:} Utilizando la cadena dada, renombra la columna del DataFrame que contiene los datos del índice.
                    \item \textbf{Tipo:} int, str o lista 1-dimensional
                    \item \textbf{Por defecto:} \texttt{None}
                \end{itemize}
        \end{itemize}

        \paragraph{Tipo de retorno}
        DataFrame con el nuevo índice o \texttt{None} si \texttt{inplace=True}.


        \subsubsection{\texttt{DataFrame.set\_index}}

        \paragraph{Descripción:}
        Establece el índice del DataFrame utilizando una o más columnas existentes o arrays del mismo tamaño. El índice puede reemplazar el índice existente o expandirse sobre él.

        \paragraph{Parámetros:}
        \begin{itemize}
            \item \texttt{keys}
                \begin{itemize}
                    \item \textbf{Descripción:} Este parámetro puede ser una clave de columna única, un array del mismo tamaño que el DataFrame que llama al método, o una lista que contiene una combinación arbitraria de claves de columna y arrays.
                    \item \textbf{Tipo:} Etiqueta o array-like o lista de etiquetas/arrays
                    \item \textbf{Por defecto:} No aplica
                \end{itemize}

            \item \texttt{drop}
                \begin{itemize}
                    \item \textbf{Descripción:} Elimina las columnas que se utilizarán como el nuevo índice.
                    \item \textbf{Tipo:} bool
                    \item \textbf{Por defecto:} \texttt{True}
                \end{itemize}

            \item \texttt{append}
                \begin{itemize}
                    \item \textbf{Descripción:} Si se deben agregar columnas al índice existente.
                    \item \textbf{Tipo:} bool
                    \item \textbf{Por defecto:} \texttt{False}
                \end{itemize}

            \item \texttt{inplace}
                \begin{itemize}
                    \item \textbf{Descripción:} Si se debe modificar el DataFrame en lugar de crear uno nuevo.
                    \item \textbf{Tipo:} bool
                    \item \textbf{Por defecto:} \texttt{False}
                \end{itemize}

            \item \texttt{verify\_integrity}
                \begin{itemize}
                    \item \textbf{Descripción:} Verifica el nuevo índice en busca de duplicados. De lo contrario, aplaza la verificación hasta que sea necesario.
                    \item \textbf{Tipo:} bool
                    \item \textbf{Por defecto:} \texttt{False}
                \end{itemize}
        \end{itemize}

        \subparagraph{Tipo de retorno}
        DataFrame con las nuevas etiquetas de fila o \texttt{None} si \texttt{inplace=True}.


        \subsubsection{\texttt{DataFrame.rename}}

        \paragraph{Descripción:}
        Renombra las etiquetas de columnas o índices. Los valores de la función o diccionario deben ser únicos (1-a-1). Las etiquetas no contenidas en un diccionario o Serie se mantendrán como están. Las etiquetas adicionales listadas no generarán un error.

        \paragraph{Parámetros:}
        \begin{itemize}
            \item \texttt{mapper}
                \begin{itemize}
                    \item \textbf{Descripción:} Transformaciones dict-like o función para aplicar a los valores del eje especificado.
                    \item \textbf{Tipo:} dict-like o función
                    \item \textbf{Por defecto:} \texttt{None}
                \end{itemize}

            \item \texttt{index}
                \begin{itemize}
                    \item \textbf{Descripción:} Alternativa para especificar el eje.
                    \item \textbf{Tipo:} dict-like o función
                    \item \textbf{Por defecto:} \texttt{None}
                \end{itemize}

            \item \texttt{columns}
                \begin{itemize}
                    \item \textbf{Descripción:} Alternativa para especificar el eje.
                    \item \textbf{Tipo:} dict-like o función
                    \item \textbf{Por defecto:} \texttt{None}
                \end{itemize}

            \item \texttt{axis}
                \begin{itemize}
                    \item \textbf{Descripción:} Eje para aplicar el renombramiento.
                    \item \textbf{Tipo:} \{0 o 'index', 1 o 'columns'\}
                    \item \textbf{Por defecto:} \texttt{0}
                \end{itemize}

            \item \texttt{copy}
                \begin{itemize}
                    \item \textbf{Descripción:} También copia los datos subyacentes.
                    \item \textbf{Tipo:} bool
                    \item \textbf{Por defecto:} \texttt{True}
                \end{itemize}

            \item \texttt{inplace}
                \begin{itemize}
                    \item \textbf{Descripción:} Si se debe modificar el DataFrame en lugar de crear uno nuevo.
                    \item \textbf{Tipo:} bool
                    \item \textbf{Por defecto:} \texttt{False}
                \end{itemize}

            \item \texttt{level}
                \begin{itemize}
                    \item \textbf{Descripción:} En caso de un MultiIndex, solo renombra las etiquetas en el nivel especificado.
                    \item \textbf{Tipo:} int o nombre de nivel
                    \item \textbf{Por defecto:} \texttt{None}
                \end{itemize}

            \item \texttt{errors}
                \begin{itemize}
                    \item \textbf{Descripción:} Si 'raise', genera un KeyError cuando un mapper dict-like, index, o columns contiene etiquetas que no están presentes en el índice que se transforma. Si 'ignore', las claves existentes serán renombradas y las claves adicionales serán ignoradas.
                    \item \textbf{Tipo:} \{'ignore', 'raise'\}
                    \item \textbf{Por defecto:} \texttt{'ignore'}
                \end{itemize}
        \end{itemize}

        \paragraph{Tipo de retorno}
        DataFrame con las etiquetas de eje renombradas o \texttt{None} si \texttt{inplace=True}.

    \section{Objeto \textit{Series}}

    Cuando extraemos una columna entera con sus respectivas filas de un conjunto de datos, el resultado es del tipo \texttt{pandas.core.series.Series}. Este objeto se define dentro del contexto de Pandas como un arreglo unidimensional etiquetado.

    En este objeto hay algunos métodos que son los mismos para los DataFrame

    \begin{itemize}
        \item \texttt{head()}
        \item \texttt{tail()}
        \item \texttt{dtype}
        \item \texttt{shape}
        \item \texttt{index}
    \end{itemize}

    \subsection{Métodos y atributos}

    \subsubsection{\texttt{to\_frame()}} Convierte la serie en un dataframe. Su argumento de entrada. Su único parámetro de entrada es la serie a convertir, y su retorno es un objeto de l tipo DataFrame.

    Existen dos tipos principales de datos en una serie de datos: numéricos y no numéricos. En función del tipo de datos existen diferentes métodos de análisis de las series. Los siguientes son métodos para tipos numéricos.

    \subsubsection{Series.describe()} Este método genera una descripción estadística de los datos.

    \paragraph{Parámetros}

    \begin{itemize}
        \item \textbf{percentiles}:
            \begin{itemize}
                \item \textbf{Tipo}: \texttt{list-like of numbers}
                \item \textbf{Descripción}: Los percentiles a incluir en la salida. Deben estar todos entre 0 y 1.
                \item \textbf{Por defecto}: \texttt{[.25, .5, .75]}
            \end{itemize}

        \item \textbf{include}:
            \begin{itemize}
                \item \textbf{Tipo}: \texttt{'all'}, \texttt{list-like of dtypes} o \texttt{None}
                \item \textbf{Descripción}: Tipo de datos a describir. Si es \texttt{'all'}, se describen todos los tipos.
                \item \textbf{Por defecto}: \texttt{None}
            \end{itemize}

        \item \textbf{exclude}:
            \begin{itemize}
                \item \textbf{Tipo}: \texttt{list-like of dtypes} o \texttt{None}
                \item \textbf{Descripción}: Tipo de datos a excluir de la descripción.
                \item \textbf{Por defecto}: \texttt{None}
            \end{itemize}

        \item \textbf{datetime\_is\_numeric}:
            \begin{itemize}
                \item \textbf{Tipo}: \texttt{bool}
                \item \textbf{Descripción}: Si es \texttt{True}, se tratan las fechas como datos numéricos y se muestra un resumen numérico. Si es \texttt{False}, se muestra un resumen basado en fecha.
                \item \textbf{Por defecto}: \texttt{False}
            \end{itemize}
    \end{itemize}

    \paragraph{Retorno}
    \texttt{Series} o \texttt{DataFrame}
    Con la descripción estadística de la Serie.


    \subsubsection{\texttt{Series.count()}} Cuenta la cantidad de datos no nulos. El tipo de salida es entero.

    \subsubsection{\texttt{Series.sum()}} Retorna la suma de los elementos en la serie de datos. Como característica particular de Pandas, puede manejar de manera apropiada con datos incompletos, o faltantes.

    \paragraph{Parámetros}

    \begin{itemize}
        \item \textbf{axis}:
            \begin{itemize}
                \item \textbf{Tipo}: \texttt{int}
                \item \textbf{Descripción}: El eje a lo largo del cual se aplicará la operación. Para Series, solo se permite el valor 0.
                \item \textbf{Por defecto}: \texttt{0}
            \end{itemize}

        \item \textbf{skipna}:
            \begin{itemize}
                \item \textbf{Tipo}: \texttt{bool}
                \item \textbf{Descripción}: Especifica si se deben excluir los valores \texttt{NaN} al calcular la suma.
                \item \textbf{Por defecto}: \texttt{True}
            \end{itemize}

        \item \textbf{level}:
            \begin{itemize}
                \item \textbf{Tipo}: \texttt{int} o \texttt{str}
                \item \textbf{Descripción}: Si la Serie tiene un MultiIndex, especifica el nivel para calcular la suma.
                \item \textbf{Por defecto}: \texttt{None}
            \end{itemize}

        \item \textbf{min\_count}:
            \begin{itemize}
                \item \textbf{Tipo}: \texttt{int}
                \item \textbf{Descripción}: El número mínimo de observaciones válidas (no-\texttt{NaN}) requeridas para realizar la suma. Si no se alcanza este número, se devuelve \texttt{NaN}.
                \item \textbf{Por defecto}: \texttt{0}
            \end{itemize}
    \end{itemize}

    \textbf{Retorno:}\texttt{scalar} Suma de los valores de la Serie.

    \subsubsection{pandas.Series.mean()} Devuelve la media aritmética de los valores de la Serie.

    \paragraph{Parámetros:}
    \begin{itemize}
        \item \textbf{axis}:
            \begin{itemize}
                \item \textbf{Tipo}: \texttt{int}
                \item \textbf{Por defecto}: \texttt{0}
            \end{itemize}
        \item \textbf{skipna}:
            \begin{itemize}
                \item \textbf{Tipo}: \texttt{bool}
                \item \textbf{Por defecto}: \texttt{True}
            \end{itemize}
    \end{itemize}

    \subsubsection{pandas.Series.median()} Devuelve la mediana de los valores de la Serie.

    \paragraph{Parámetros:}
    \begin{itemize}
        \item \textbf{axis}, \textbf{skipna}, \textbf{numeric\_only}: Igual que en \texttt{Series.mean()}.
    \end{itemize}

    \subsubsection{pandas.Series.std()} Devuelve la desviación estándar de los valores de la Serie.

    \paragraph{Parámetros:}
    \begin{itemize}
        \item \textbf{axis}, \textbf{skipna}, \textbf{level}: Igual que en \texttt{Series.mean()}.
        \item \textbf{ddof}
            \begin{itemize}
                \item \textbf{Tipo}: \texttt{int}
                \item \textbf{Por defecto}: \texttt{1}
                \item \textbf{Desripción}: Delta de los grados de libertad.
            \end{itemize}
    \end{itemize}

    \subsubsection{pandas.Series.min()} Devuelve el valor mínimo de la Serie.

    \paragraph{Parámetros:}
    \begin{itemize}
        \item \textbf{axis}, \textbf{skipna}, \textbf{numeric\_only}: Igual que en \texttt{Series.mean()}.
    \end{itemize}

    \subsubsection{pandas.Series.max()} Devuelve el valor máximo de la Serie.

    \paragraph{Parámetros:}
    \begin{itemize}
        \item \textbf{axis}, \textbf{skipna}, \textbf{numeric\_only}: Igual que en \texttt{Series.mean()}.
    \end{itemize}

    \subsubsection{pandas.Series.unique()} Devuelve los valores únicos de la Serie.

    \paragraph{Parámetros:} Ninguno.

    \paragraph{Tipo de retorno:} \texttt{ExtensionArray}

    \subsubsection{pandas.Series.value\_counts()} Devuelve una Serie que representa la frecuencia de valores únicos.

    \paragraph{Parámetros:}
    \begin{itemize}
        \item \textbf{normalize}:
            \begin{itemize}
                \item \textbf{Tipo}: \texttt{bool}
                \item \textbf{Descripción}: Si es \texttt{True}, devuelve las proporciones en lugar de las cuentas.
                \item \textbf{Por defecto}: \texttt{False}
            \end{itemize}
        \item \textbf{sort}:
            \begin{itemize}
                \item \textbf{Tipo}: \texttt{bool}
                \item \textbf{Por defecto}: \texttt{True}
            \end{itemize}
        \item \textbf{ascending}:
            \begin{itemize}
                \item \textbf{Tipo}: \texttt{bool}
                \item \textbf{Por defecto}: \texttt{False}
            \end{itemize}
        \item \textbf{bins}:
            \begin{itemize}
                \item \textbf{Tipo}: \texttt{int}
                \item \textbf{Descripción}: Solo para Series numéricas. Divide los valores en intervalos.
                \item \textbf{Por defecto}: \texttt{None}
            \end{itemize}
        \item \textbf{dropna}:
            \begin{itemize}
                \item \textbf{Tipo}: \texttt{bool}
                \item \textbf{Descripción}: Si es \texttt{True}, excluye los valores \texttt{NaN}.
                \item \textbf{Por defecto}: \texttt{True}
            \end{itemize}
    \end{itemize}
    \paragraph{Tipo de retorno:} \texttt{Series}

    Para las series con valores no numéricos, los atributos y métodos como \texttt{shape}, \texttt{size}, \texttt{count()} son muy similares a los de valores numéricos. Por su parte otros métodos como \texttt{describe()} muestra información como cuál es el valor más repetido, su respectiva frecuencia, etc.

    Métodos como \texttt{min()} que retorna el valor más "pequeño" alfabéticamente hablando, tienen sus diferencias con los valores numéricos.


    \subsubsection{Ejemplo} Para un conjunto de datos de las medallas de oro de los juegos olímpicos históricos de verano, el siguiente código realiza una exploración de cuál es el nombre del atleta que más oros consiguió en la edición de los juegos olímpicos de 1972:

    \begin{verbatim}
            import pandas as pd
            
            df = pd.read_csv("summer1972.csv",index_col="Year")
            
            Athlete = df["Athlete"]
            
            print(Athlete.loc[1972].value_counts().index[0])
            \end{verbatim}
    \subsection{Creación de series}

    A partir de cualquier conjunto de datos importado o creado, si seleccionamos o extraemos una de las columnas, sea total o filtrada de alguna manera, vamos a obtener un objeto del tipo \textit{Series}.
    La siguiente línea de código es un ejemplo de cómo se consigue una serie directamente importada del archivo:

    \begin{verbatim}
            pd.read_csv("file.csv", usecols = ["name_col"]).squeeze()
            \end{verbatim}
    De este modo, la variable retornada será del tipo \texttt{Series} en lugar de \texttt{DataFrame}.
    Por su parte, existe el método para convertir una lista de python a una serie de pandas:

    \begin{verbatim}
            pd.Series([10,25,6,36,2])
            \end{verbatim}
    Se pueden establecer las etiquetas a las filas de la serie creada de la siguiente forma:
    \begin{verbatim}
            pd.Series([10,25,6,36,2], index = ["Mon","Tue","Wed","Thu","Fri"])
            \end{verbatim}
    Y se puede añadir la etiqueta de la columna también:

    \begin{verbatim}
            pd.Series([10,25,6,36,2], index = ["Mon","Tue","Wed","Thu","Fri"], name = "Sales")
            \end{verbatim}
    \subsubsection{\texttt{pd.Series}} Retorna un objeto del tipo \texttt{Series} a partir de los datos ingresados.

    \paragraph{Parámetros}
    \begin{itemize}
        \item \textbf{data}:
            \begin{itemize}
                \item \textbf{Descripción:} los datos que serán los elementos de la serie.
                \item \textbf{Tipo:} elementos iterables, del tipo arreglo (\texttt{numpy.array}) o diccionarios.
                \item \textbf{Por defecto:} \texttt{None}
            \end{itemize}
        \item \textbf{index}:
            \begin{itemize}
                \item \textbf{Descripción:} Es el conjunto de etiquetas para las filas de la serie.
                \item \textbf{Tipo:} Tipo arreglo, puede ser una lista con los nombres requeridos.
                \item \textbf{Por defecto:} \texttt{None}
            \end{itemize}
        \item \textbf{data}:
            \begin{itemize}
                \item \textbf{Descripción:} los datos que serán los elementos de la serie.
                \item \textbf{Tipo:} elementos iterables, del tipo arreglo (\texttt{numpy.array}) o diccionarios.
                \item \textbf{Por defecto:} \texttt{None}
            \end{itemize}
    \end{itemize}


    \paragraph{Tipo de retorno}: \texttt{Series}


    Por otro lado, se puede crear una variable del tipo \texttt{Series} a partir de arreglos de \textit{numpy}, una lista de python, tupla, o dicccionario:

    \begin{verbatim}
            import pandas as pd
            import numpy as np
            sales = np.array([10,25,6,36,2])
            pd.Series(sales)
            sales = [10,25,6,36,2]
            \end{verbatim}
    Es importante mencionar la diferencia entre las referencias de filas realizadas con \texttt{loc} y las de \texttt{iloc}. Esta última se refiere al \textbf{índice}, iniciando desde cero hasta la longitud menos uno. La primera, \texttt{loc} se refiere a la \textbf{etiqueta}, la cual puede variar.

    \subsubsection{\texttt{sort\_index}}

    \paragraph{Descripción:}
    Ordena la Serie por las etiquetas del índice. Devuelve una nueva Serie ordenada por etiqueta si el argumento \texttt{inplace} es \texttt{False}, de lo contrario, actualiza la Serie original y devuelve \texttt{None}.

    \paragraph{Parámetros:}

    \begin{itemize}
        \item \texttt{axis}
            \begin{itemize}
                \item \textbf{Descripción:} No utilizado. Parámetro necesario para compatibilidad con DataFrame.
                \item \textbf{Tipo:} \{0 o 'index'\}
                \item \textbf{Por defecto:} 0
            \end{itemize}
        \item \texttt{level}
            \begin{itemize}
                \item \textbf{Descripción:} Si no es \texttt{None}, ordena los valores en el nivel de índice especificado.
                \item \textbf{Tipo:} int, opcional
                \item \textbf{Por defecto:} \texttt{None}
            \end{itemize}
        \item \texttt{ascending}
            \begin{itemize}
                \item \textbf{Descripción:} Ordena en dirección ascendente o descendente.
                \item \textbf{Tipo:} bool o lista de bools
                \item \textbf{Por defecto:} \texttt{True}
            \end{itemize}
        \item \texttt{inplace}
            \begin{itemize}
                \item \textbf{Descripción:} Si es \texttt{True}, realiza la operación en el lugar.
                \item \textbf{Tipo:} bool
                \item \textbf{Por defecto:} \texttt{False}
            \end{itemize}
        \item \texttt{kind}
            \begin{itemize}
                \item \textbf{Descripción:} Elección del algoritmo de ordenación.
                \item \textbf{Tipo:} \{'quicksort', 'mergesort', 'heapsort', 'stable'\}
                \item \textbf{Por defecto:} 'quicksort'
            \end{itemize}
        \item \texttt{na\_position}
            \begin{itemize}
                \item \textbf{Descripción:} Posición de los NaNs en la Serie ordenada.
                \item \textbf{Tipo:} \{'first', 'last'\}
                \item \textbf{Por defecto:} 'last'
            \end{itemize}
        \item \texttt{sort\_remaining}
            \begin{itemize}
                \item \textbf{Descripción:} Si es \texttt{True}, también ordena por otros niveles después de ordenar por el nivel especificado.
                \item \textbf{Tipo:} bool
                \item \textbf{Por defecto:} \texttt{True}
            \end{itemize}
        \item \texttt{ignore\_index}
            \begin{itemize}
                \item \textbf{Descripción:} Si es \texttt{True}, el eje resultante se etiquetará de 0 a \( n - 1 \).
                \item \textbf{Tipo:} bool
                \item \textbf{Por defecto:} \texttt{False}
            \end{itemize}
        \item \texttt{key}
            \begin{itemize}
                \item \textbf{Descripción:} Si no es \texttt{None}, aplica la función clave a los valores del índice antes de ordenar.
                \item \textbf{Tipo:} callable, opcional
                \item \textbf{Por defecto:} \texttt{None}
            \end{itemize}
    \end{itemize}

    \paragraph{Tipo de retorno}
    Serie o \texttt{None}. La Serie original ordenada por las etiquetas o \texttt{None} si \texttt{inplace=True}.

    \section{Objeto \texttt{index}}

    Uno de los atributos de un dataframe es \texttt{df.columns}, al imprimir este tipo de objeto vemos que su salida es del tipo

    \begin{verbatim}
            Index(['col1', 'col2', 'col3'], dtype='object')
            \end{verbatim}

    Estas son instancias de la clase \texttt{pandas.index} y se trata de una secuencia inmutable que se utiliza para la indexación y el alineamiento de los datos. Es el objeto en el que se guardan las etiquetas de los ejes en todos los objetos de Pandas.

    \subsection{Métodos}

    \subsubsection{\texttt{Index.append}}

    \paragraph{Descripción:}
    Agrega una colección de opciones de índice juntas.

    \paragraph{Parámetros:}

    \begin{itemize}
        \item \texttt{other}
            \begin{itemize}
                \item \textbf{Descripción:} Índice o lista/tupla de índices a agregar.
                \item \textbf{Tipo:} Index o list/tuple de indices
                \item \textbf{Por defecto:} No aplica
            \end{itemize}
    \end{itemize}

    \paragraph{Tipo de retorno}
    Índice (\texttt{Index}).

    \subsubsection{\texttt{Index.drop}}

    \paragraph{Descripción:}
    Crea un nuevo índice con la lista de etiquetas pasadas eliminadas.

    \paragraph{Parámetros:}

    \begin{itemize}
        \item \texttt{labels}
            \begin{itemize}
                \item \textbf{Descripción:} Etiquetas para eliminar del índice.
                \item \textbf{Tipo:} array-like o escalar
                \item \textbf{Por defecto:} No aplica
            \end{itemize}
        \item \texttt{errors}
            \begin{itemize}
                \item \textbf{Descripción:} Si es 'ignore', suprime el error y se eliminan las etiquetas existentes.
                \item \textbf{Tipo:} \{'ignore', 'raise'\}
                \item \textbf{Por defecto:} 'raise'
            \end{itemize}
    \end{itemize}

    \paragraph{Tipo de retorno}
    Índice (\texttt{Index}). Será del mismo tipo que el índice original, excepto para \texttt{RangeIndex}.

    \paragraph{Excepciones}
    \texttt{KeyError} si no se encuentran todas las etiquetas en el eje seleccionado.



    \paragraph{\texttt{Index.isin}}

    \paragraph{Descripción:}
    Devuelve un array booleano donde los valores del índice están en los valores pasados. Calcula un array booleano que indica si cada valor del índice se encuentra en el conjunto de valores pasado. La longitud del array booleano devuelto coincide con la longitud del índice.

    \paragraph{Parámetros:}

    \begin{itemize}
        \item \texttt{values}
            \begin{itemize}
                \item \textbf{Descripción:} Valores buscados.
                \item \textbf{Tipo:} conjunto o lista
                \item \textbf{Por defecto:} No aplica
            \end{itemize}
        \item \texttt{level}
            \begin{itemize}
                \item \textbf{Descripción:} Nombre o posición del nivel del índice a utilizar (si el índice es un \texttt{MultiIndex}).
                \item \textbf{Tipo:} cadena o entero, opcional
                \item \textbf{Por defecto:} \texttt{None}
            \end{itemize}
    \end{itemize}

    \paragraph{Tipo de retorno}
    Array de NumPy de valores booleanos (\texttt{np.ndarray[bool]}).

    \paragraph{Notas}
    En el caso de \texttt{MultiIndex}, debe especificar los valores como un objeto similar a una lista que contenga tuplas que tengan la misma longitud que el número de niveles, o especificar el nivel. De lo contrario, se generará un \texttt{ValueError}.





    \subsubsection{\texttt{Index.unique}}

    \paragraph{Descripción:}
    Devuelve los valores únicos en el índice. Los valores únicos se devuelven en el orden en que aparecen; esto no ordena los valores.

    \paragraph{Parámetros:}

    \begin{itemize}
        \item \texttt{level}
            \begin{itemize}
                \item \textbf{Descripción:} Devuelve solo los valores del nivel especificado (para \texttt{MultiIndex}). Si es un entero, obtiene el nivel por posición entera; de lo contrario, por nombre del nivel.
                \item \textbf{Tipo:} entero o hashable, opcional
                \item \textbf{Por defecto:} \texttt{None}
            \end{itemize}
    \end{itemize}

    \paragraph{Tipo de retorno}
    Índice (\texttt{Index}).

    \paragraph{Ver también}
    \begin{itemize}
        \item \texttt{unique}: Array de NumPy de valores únicos en esa columna.
        \item \texttt{Series.unique}: Devuelve los valores únicos del objeto Series.
    \end{itemize}



    \subsubsection{\texttt{Index.duplicated}}

    \paragraph{Descripción:}
    Indica los valores duplicados del índice. Los valores duplicados se indican como valores \texttt{True} en el array resultante. Se pueden indicar todos los duplicados, todos excepto el primero o todos excepto el último.

    \paragraph{Parámetros:}

    \begin{itemize}
        \item \texttt{keep}
            \begin{itemize}
                \item \textbf{Descripción:} El valor o valores en un conjunto de duplicados que se marcarán como faltantes.
                \item \textbf{Tipo:} \{'first', 'last', False\}
                \item \textbf{Por defecto:} 'first'
            \end{itemize}
    \end{itemize}

    \paragraph{Tipo de retorno}
    Array de NumPy de valores booleanos (\texttt{np.ndarray[bool]}).

    \paragraph{Ejemplos}
    Por defecto, para cada conjunto de valores duplicados, la primera aparición se establece en \texttt{False} y todas las demás en \texttt{True}. Al usar 'last', la última aparición de cada conjunto de valores duplicados se establece en \texttt{False} y todas las demás en \texttt{True}. Al establecer \texttt{keep} en \texttt{False}, todos los duplicados son \texttt{True}.



    \subsubsection{\texttt{Index.sort\_values}}

    \paragraph{Descripción:}
    Devuelve una copia ordenada del índice. Opcionalmente, devuelve los índices que ordenaron el índice en sí.

    \paragraph{Parámetros:}

    \begin{itemize}
        \item \texttt{return\_indexer}
            \begin{itemize}
                \item \textbf{Descripción:} ¿Deberían devolverse los índices que ordenarían el índice?
                \item \textbf{Tipo:} bool
                \item \textbf{Por defecto:} \texttt{False}
            \end{itemize}
        \item \texttt{ascending}
            \begin{itemize}
                \item \textbf{Descripción:} ¿Deberían ordenarse los valores del índice en orden ascendente?
                \item \textbf{Tipo:} bool
                \item \textbf{Por defecto:} \texttt{True}
            \end{itemize}
        \item \texttt{na\_position}
            \begin{itemize}
                \item \textbf{Descripción:} Argumento 'first' coloca NaNs al principio, 'last' coloca NaNs al final.
                \item \textbf{Tipo:} \{'first', 'last'\}
                \item \textbf{Por defecto:} 'last'
            \end{itemize}
        \item \texttt{key}
            \begin{itemize}
                \item \textbf{Descripción:} Si no es \texttt{None}, aplica la función clave a los valores del índice antes de ordenar.
                \item \textbf{Tipo:} callable, opcional
                \item \textbf{Por defecto:} \texttt{None}
            \end{itemize}
    \end{itemize}

    \paragraph{Tipo de retorno}
    Índice (\texttt{pandas.Index}) y opcionalmente un array de NumPy (\texttt{numpy.ndarray}).



    \subsubsection{\texttt{Index.get\_loc}}

    \paragraph{Descripción:}
    Obtiene la ubicación entera, el segmento o la máscara booleana para la etiqueta solicitada.

    \paragraph{Parámetros:}

    \begin{itemize}
        \item \texttt{key}
            \begin{itemize}
                \item \textbf{Descripción:} Etiqueta para la cual se desea obtener la ubicación.
                \item \textbf{Tipo:} label
                \item \textbf{Por defecto:} No aplica
            \end{itemize}
    \end{itemize}

    \paragraph{Tipo de retorno}
    Entero si el índice es único, segmento si el índice es monótono, de lo contrario, máscara.



    \subsubsection{\texttt{Index.get\_indexer}}

    \paragraph{Descripción:}
    Calcula el indexador y la máscara para el nuevo índice dado el índice actual. El indexador debe usarse como entrada para \texttt{ndarray.take} para alinear los datos actuales con el nuevo índice.

    \paragraph{Parámetros:}

    \begin{itemize}
        \item \texttt{target}
            \begin{itemize}
                \item \textbf{Descripción:} Índice objetivo.
                \item \textbf{Tipo:} Index
                \item \textbf{Por defecto:} No aplica
            \end{itemize}
        \item \texttt{method}
            \begin{itemize}
                \item \textbf{Descripción:} Método para encontrar coincidencias inexactas.
                \item \textbf{Tipo:} \{None, 'pad'/'ffill', 'backfill'/'bfill', 'nearest'\}, opcional
                \item \textbf{Por defecto:} Coincidencias exactas solamente
            \end{itemize}
        \item \texttt{limit}
            \begin{itemize}
                \item \textbf{Descripción:} Número máximo de etiquetas consecutivas en el objetivo para coincidencias inexactas.
                \item \textbf{Tipo:} int, opcional
                \item \textbf{Por defecto:} No aplica
            \end{itemize}
        \item \texttt{tolerance}
            \begin{itemize}
                \item \textbf{Descripción:} Distancia máxima entre las etiquetas originales y nuevas para coincidencias inexactas.
                \item \textbf{Tipo:} opcional
                \item \textbf{Por defecto:} No aplica
            \end{itemize}
    \end{itemize}

    \paragraph{Tipo de retorno}
    Array de NumPy de enteros (\texttt{np.ndarray[np.intp]}).



    \subsubsection{\texttt{Index.intersection}}

    \paragraph{Descripción:}
    Forma la intersección de dos objetos \texttt{Index}. Esto devuelve un nuevo \texttt{Index} con elementos comunes al índice y al otro objeto.

    \paragraph{Parámetros:}

    \begin{itemize}
        \item \texttt{other}
            \begin{itemize}
                \item \textbf{Descripción:} Otro índice o objeto similar a un array con el que formar la intersección.
                \item \textbf{Tipo:} Index o array-like
                \item \textbf{Por defecto:} No aplica
            \end{itemize}
        \item \texttt{sort}
            \begin{itemize}
                \item \textbf{Descripción:} Si se debe ordenar el índice resultante.
                \item \textbf{Tipo:} True, False o None
                \item \textbf{Por defecto:} \texttt{False}
            \end{itemize}
    \end{itemize}

    \paragraph{Tipo de retorno}
    Índice (\texttt{Index}).



    \subsubsection{\texttt{Index.tolist}}

    \paragraph{Descripción:}
    Devuelve una lista de los valores. Cada uno de estos es un tipo escalar, que es un escalar de Python (para \texttt{str}, \texttt{int}, \texttt{float}) o un escalar de Pandas (para \texttt{Timestamp/Timedelta/Interval/Period}).

    \paragraph{Parámetros:}
    No tiene parámetros.

    \paragraph{Tipo de retorno}
    Lista de Python (\texttt{list}).

    \paragraph{Ver también}
    \begin{itemize}
        \item \texttt{numpy.ndarray.tolist}: Devuelve el array como una lista de Python anidada con \texttt{a.ndim} niveles de profundidad.
    \end{itemize}

    \paragraph{Ejemplos}
    Para Series:
    \begin{verbatim}
            >>> s = pd.Series([1, 2, 3])
            >>> s.to_list()
            [1, 2, 3]
            \end{verbatim}
    Para Index:
    \begin{verbatim}
            >>> idx = pd.Index([1, 2, 3])
            >>> idx
            Index([1, 2, 3], dtype='int64')
            >>> idx.to_list()
            [1, 2, 3]
            \end{verbatim}





    \subsection{Atributos}

    la lista de métodos es la siguiente:

    \subsubsection{~\hspace{2em} \texttt{array:}} El ExtensionArray de los datos que respaldan esta Serie o Índice.
    \subsubsection{~\hspace{2em} \texttt{dtype:}} Devuelve el objeto dtype de los datos subyacentes.
    \subsubsection{~\hspace{2em} \texttt{has\_duplicates:}} Verifica si el Índice tiene valores duplicados.
    \subsubsection{~\hspace{2em} \texttt{hasnans:}} Devuelve True si hay algún NaN.
    \subsubsection{~\hspace{2em} \texttt{inferred\_type:}} Devuelve una cadena del tipo inferido a partir de los valores.
    \subsubsection{~\hspace{2em} \texttt{is\_monotonic\_decreasing:}} Devuelve un booleano si los valores son iguales o decrecientes.
    \subsubsection{~\hspace{2em} \texttt{is\_monotonic\_increasing:}} Devuelve un booleano si los valores son iguales o crecientes.
    \subsubsection{~\hspace{2em} \texttt{is\_unique:}} Devuelve si el índice tiene valores únicos.
    \subsubsection{~\hspace{2em} \texttt{name:}} Devuelve el nombre del Índice o MultiÍndice.
    \subsubsection{~\hspace{2em} \texttt{nbytes:}} Devuelve el número de bytes en los datos subyacentes.
    \subsubsection{~\hspace{2em} \texttt{ndim:}} Número de dimensiones de los datos subyacentes, por definición 1.
    \subsubsection{~\hspace{2em} \texttt{nlevels:}} Número de niveles.
    \subsubsection{~\hspace{2em} \texttt{shape:}} Devuelve una tupla de la forma de los datos subyacentes.
    \subsubsection{~\hspace{2em} \texttt{size:}} Devuelve el número de elementos en los datos subyacentes.
    \subsubsection{~\hspace{2em} \texttt{values:}} Devuelve una matriz que representa los datos en el Índice.



    % -------- MÉTODOS ----------------------
    % \paragraph{\texttt{NOMBRE}}

    % \subparagraph{Descripción}
    % \subparagraph{Parámetros}

    % \begin{itemize}
    %     \item \texttt{}
    %         \begin{itemize}
    %             \item \textbf{Descripción:}
    %             \item \textbf{Tipo:}
    %             \item \textbf{Por defecto:}
    %         \end{itemize}
    % \end{itemize}

    % \subparagraph{Tipo de retorno}