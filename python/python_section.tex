\chapter{Python}


\section{Fundamentos}

\subsection{Scope y variables del entorno}

El término "scope" en el contexto de la programación se puede traducir al español como "ámbito" o "alcance". El alcance o ámbito de una variable en Python se refiere a la región del programa donde esa variable es válida y puede ser accedida.

En Python, existen diferentes niveles de alcance, como el alcance global y el alcance local. El alcance global se refiere a las variables que están definidas fuera de cualquier función o clase y son accesibles desde cualquier parte del programa. El alcance local se refiere a las variables que están definidas dentro de una función o clase y solo son accesibles dentro de esa función o clase. El ejemplo más claro puede ser visto a continuación

\begin{verbatim}
enemies = 1

def increase_enemies():
    enemies = 2
    print("enemies is", enemies)

increase_enemies()
print("enemies is", enemies)
\end{verbatim}

En este caso se llama a una función que cambia la variable "enemies" de 1 a 2. Sin embarago, la salida de este programa es

\begin{verbatim}
enemies is 2
enemies is 1
\end{verbatim}

Podemos ver que fuera de la función, que fue donde se declaró la variable \texttt{enemies} esta no cambió de valor; solamente fue cambiada dentro de la función. Si por ejemplo tratáramos de escribir un programa que declare una variable solamente dentro de la función y la intentamos imprimir fuera de ella,

\begin{verbatim}
def drink():
    var = 1
    print(var)


print(var)
\end{verbatim}

Saltará un error \texttt{NameError: name 'var' is not defined}. Esto es porque en este caso y en el anterior, las variables \texttt{enemies} y \texttt{var} son variables locales y están dentro del ámbito o alcance de la función que las declara o modifica.\\

Por su parte, cualquier variable declarada fuera de todas las funciones y clases, son denominadas como variables locales y el ámbito o alcance de estas será global. Y es accesible desde cualquier parte del programa. Este concepto de ámbito o alcance no solamente aplica para las variables sino que también aplica para funciones, entre otro tipo de elementos.

\subsubsection{Espacio de nombres}

El concepto de espacio de nombres hace referencia a la manera que se tiene de organizar los diferentes nombres; sean de clases, funciones, variables, etc. Cada espacio de nombre puede ser visto como un contenedor con todos los nombres definidos. Existen diferentes tipos de namespaces:

\begin{enumerate}
    \item Namespace Global: Es el namespace de nivel superior y contiene los nombres definidos en el alcance global, es decir, fuera de cualquier función o clase. Los nombres definidos en el namespace global son accesibles desde cualquier parte del programa.
    \item Namespace Local: Es el namespace creado cuando se define una función o clase. Contiene los nombres definidos dentro de esa función o clase y solo son accesibles desde su interior.
    \item Namespace de Módulo: Cada archivo de Python se considera un módulo y tiene su propio namespace. Los nombres definidos en un módulo son accesibles desde otros módulos si se realiza una importación.
    \item Namespace Incorporado (Built-in): Contiene los nombres predefinidos que son proporcionados por Python de manera predeterminada. Estos nombres incluyen funciones y tipos incorporados como print(), len(), str(), etc.
\end{enumerate}

Una característica impotante de Python es que no tiene un ámbito de bloque, a diferencia de otros lenguajes de programación. Esto quiere decir, por ejemplo, 

\begin{verbatim}
if var1:
    <code>
    <code>
    <code>
    <code>
\end{verbatim}

Si el lenguaje tiene ámbito de bloque, entonces cualquier definicion dentro de las líneas subordinadas al \texttt{if} anterior solamente existirán dentro del \texttt{if}. En python esto no pasa, cualqueir variable que este definida aquí estará dentro del ambito en que se encuentre el \texttt{if}.

\subsubsection{Cómo modificar una variable global}

Una cosa importante dentro del tema de los entornos de que siempre que tenemos dos ámbitos diferentes; por ejemplo el entorno global y un entrono local, una variable global comparada con una variable local son dos variables completamente diferentes, aunque tengan el mismo nombre. ES muy mala idea nombrar dos variables con el mismo nombre, aunque estén en dos ámbitos diferentes. En el caso dado de que se requiera modificar el valor de una variable global dentro de una variable local, es imprescindible indicar exlícitamente que se trata de una variable global:

\begin{verbatim}
var = 2
def fun():
    global var
    var = 1
    print(var)
fun()
print(var)
\end{verbatim}

En este caso, no se crea una nueva variable en el entorno local de la función, sino que se modifica la variable global declarada al principio.

En general no es muy recuente el uso de este método de cambio de variables globales, porque se presta para confusiones y facilita de ciera manera los erroes. Sin embargo, el uso de las variables globales es importante por ejemplo cuando se necesita declarar una variable constante dentro del programa. Siempre se usa como convención usar letras mayúsculas y barras bajas para declarar constantes dentro del programa (ejemplo \texttt{MY\_EMAIL = "sebas@unal.edu"}).

\section{Tipos de datos, estructuras, objetos incorporados, funciones}

\subsection{variables y su almacenamiento}

al entrar en una funcion, normalmente el entorno se reinicia, con lo cual la mayoría de las variables que se declaren o se modifiquen solamente lo hará en ese entorno. Sin embargo, algunas funciones de algunos tipos de datos (mayoritariamente modificar) como \texttt{list.append()} 

\subsection{Funciones}

Una manera de especificar mejor los argumentos de las funciones, es mediante la siguiente fórma:

\texttt{my\_fun(a=1, b=2, c=3)}

\subsection{Tupla}

De manera similar que una secuencia de caracteres, una tupla es una secuencia de datos de distintos tipos. Colección de distintos datos. Este no se puede modificar una vez se declara. Esto es, no son mutables y por tanto se almacenan en un solo bloque de memoria.\\\

\texttt{tupla = (2,"hola",False)} \\\

Si se suman las tuplas \texttt{a} y \texttt{b}, el resultado es una concatenación \\\

\texttt{tupla = (1,2,3)} \\
\texttt{tupla2 = (4,5,True)} \\
\texttt{tupla3 = tupla + tupla2} \\
\texttt{print(tupla3)} \\
La salida es\\
\texttt{(1,2,3,4,5,True)}\\\

Multiplicar una tupla:

\begin{verbatim}
a = (1,2)
print(a*5)
\end{verbatim}
\begin{lstlisting}
output: (1, 2, 1, 2, 1, 2, 1, 2, 1, 2)
\end{lstlisting}

Recorrer una tupla:
\begin{verbatim}
for i in tuple:
    print(i)
\end{verbatim}

Verificar si es miembro

\begin{verbatim}
    3 in (1,2,3)
\end{verbatim}

La tuplas son útiles para hacer cambios de variables en una linea misma: \\\

\texttt{x = 2}\\
\texttt{y = 5}\\
\texttt{(x,y) = (y,x)}\\
\texttt{print(x)}\\
\texttt{output: 5}\\\

También para definir una función en la que retornan varios valores

\begin{verbatim}
def funcion(x,y):
    q = x // y
    r = x % y
    return (q,r)
    
(cociente,residuo) = funcion(47,11)
print(residuo)
\end{verbatim}
\begin{lstlisting}
output: 3
\end{lstlisting}

Para retornar el enésimo elemento de una tupla se pone \texttt{tuple[i]}. Recordar que los índices van dede cero hasta \texttt{length(tuple)-1}. 

\textbf{Nota:} \texttt{tuple[1:5]} retornará los valores de la tupla desde el índice \textbf{2} hasta el \textbf{4}.

\begin{itemize}
    \item \texttt{len(tuple)}: Retorna el tamaño de la tupla
    \item \texttt{max(tuple)}: Retorna el valor máximo de la tupla. Si en la tupla hay cadenas de caracteres, tuplas o listas, retorna un error.
    \item \texttt{tuple(List)}: Retorna una tupla conformada con los elementos de la lista List.
\end{itemize}

\subsection{Lista}

Otro tipo de arreglo de datos es la lista. La principal diferencia entre tupla y lista es que la lista sí es mutable y también ocupa dos bloques de memoria; esto hace que trabajar con tuplas sea más rápido pero la ventaja de la lista es que es modificable.

\begin{verbatim}
    list1 = ['physics', 'chemistry', 1997, 2000]
\end{verbatim}

El tipo de acceso de los elementos de una lista es el mismo que para las tuplas. De la misma forma las operaciones; ver la sección anterior en las operaciones de listas. \\\

\subsubsection{Lista de funciones}

\paragraph{\texttt{len(list)}} Retorna el tamaño de la lista.
\paragraph{\texttt{max(list)}} Retorna el valor del máximo, si la lista contiene combinaciones de numeros y caracteres o listas o tuplas, genera error.
\paragraph{\texttt{min(list)}} Retorna el valor mínimo dentro de la lista.
\paragraph{\texttt{list(seq)}} Retorna una lista compuesta por los elementos de \texttt{seq}.
\paragraph{\texttt{sorted(list)}} Retorna una lista con los elementos de \texttt{list} ordenados de menor a mayor.


\subsubsection{Lista de métodos}

\paragraph{\texttt{list.append(obj)}} Añade el objeto \texttt{obj} al final de la lista

\paragraph{\texttt{list.count(obj)}} Retorna el número de veces que el objeto \texttt{obj} ocurre en la lista.

\paragraph{\texttt{list.extend(seq)}} Añade el contenido de \texttt{seq} a la lista. Lo añade al final de la lista.

\paragraph{\texttt{list.index(obj)}} Retorna el índice más pequeño en la lista en que el objeto \texttt{obj} aparece.

\paragraph{\texttt{list.insert(index, obj)}} Inserta el objeto \texttt{obj} en la casilla \texttt{index} de la lista, moviendo el resto una posición.

\paragraph{\texttt{list.pop(obj = list[-1])}} Remueve y retorna el objeto que se encuentre en la posición \texttt{obj}. Por defecto si no se ingresa argumento, remueve el último objeto de la lista.

\paragraph{\texttt{list.remove(obj)}} Remueve el primer objeto \texttt{obj} que encuentre en la lista.

\paragraph{\texttt{list.reverse()}} Invierte el orden de los componentes de la lista.

\paragraph{\texttt{list.sort(key=None)}} Organiza los elementos de la lista, si hay una directiva de oredenamiento, se puede ingresar como el argumento \texttt{key}, por defecto, organiza de menor a mayor.

\paragraph{\texttt{list.clear(}} Elimina todos los componentes dentro de la lista dejándola como una lista vacía.

\paragraph{\texttt{list.copy()}} Retorna una copia de la lista.

\subparagraph{Nota} Si se declara una lista como sigue
\begin{verbatim}
    A = [1,2,3]
    B = A
\end{verbatim}
Tanto \texttt{A} como \texttt{B} están apuntando al mismo objeto, o dirección de memoria. Para realizar una copia de \texttt{A} en otro espacio de memoria se utiliza

\begin{verbatim}
    B = A[:]
\end{verbatim}

\subsection{Diccionario}

Es una lista especial en la que se puede dar un identificador especial al índice de la misma

\begin{verbatim}
    dict = {'Name': 'Zara', 'Age': 7, 'Class': 'First'}
    print(dict["Name"])
\end{verbatim}

El primer objeto del diccionario tiene un identificador llamado "Name" y un valor asociado a él que en este caso es "Zara". La salida del código anterior será

\begin{verbatim}
    Zara
\end{verbatim}

Se puede modificar el valor de una entrada en el diccionario y se puede también añadir una nueva entrada

\begin{verbatim}
    dict = {'Name': 'Zara', 'Age': 7, 'Class': 'First'}
    dict['Age'] = 8; # update existing entry
    dict['School'] = "DPS School" # Add new entry
\end{verbatim}

Para borrar elementos de un diccionario 

\begin{verbatim}
    del(dict["Name"])
\end{verbatim}

Una propiedad importante de los diccionarios es que los elementos pueden ser cualquier objeto de python. Las 'llaves' o identificadores deben ser objetos inmutables como cadenas de caracteres o tuplas.

\subsubsection{Funciones}

\paragraph{\texttt{len(dic)}}

\paragraph{\texttt{srt(dic)}} Retorna una cadena de caracteres imprimible de los elementos que contiene el diccionario \texttt{dic}


\subsubsection{Métodos}

\paragraph{\texttt{dic.clear()}}

\paragraph{\texttt{dic.copy()}}

\paragraph{\texttt{dic.fromkeys(iterable,value)}} Retorna un nuevo diccionario cuyas 'llaves' estarán determinadas por los elementos de \texttt{iterable} y con un valor asociado (único) de \texttt{value}

\paragraph{\texttt{dic.get(key, default=None)}} Retorna el valor correspondiente a la llave \texttt{key}. El segundo argumento es el retorno cuando no hay una llave que corresponda.

\paragraph{\texttt{dic.items()}} Este método retorna una lista de tuplas, cada tupla corresponde a la llave y al valor correspondiente.

\paragraph{\texttt{dic.keys()}} Retorna una vista de todas las llaves del diccionario. Se puede conseguir la lista nativa a través de \texttt{list()}.

\paragraph{\texttt{dic.setdefault(key, default = None)}} Es similar a \texttt{get()} con la diferencia de que si la llave \texttt{key} no está en el diccionario, entonces la añade y su valor correspondiente será \texttt{default}

\paragraph{\texttt{dic.update(dict2)}} Actualiza el diccionario añadiendo todos los pares (llave-valor) de \texttt{dict2}.

\paragraph{\texttt{dic.values()}} Retorna una vista de los valores del diccionario. Se puede conseguir la lista nativa a través de \texttt{list()}.

\subsection{\texttt{open()}}

El retorno de esta función es un objeto \texttt{file}.

\begin{verbatim}
open (file, mode='r', buffering=- 1, encoding=None, errors=None, newline=None, closefd=True, opener=None)
\end{verbatim}

\begin{itemize}
    \item \texttt{file} es un objeto \texttt{path-like}, es el nombre del archivo a abrir (incluyendo la ruta si es necesario) o crear.
    \item \texttt{mode} es un string opcional que especifica el modo en el que el archivo se abre, por defecto \texttt{'r'} para leer \texttt{'w'} para escribir, truncando el archivo primero \texttt{'x'} para creación de archivo nuevo, falla si ya hay un archivo con ese nombre, \texttt{'a'} para escribir en el archivo, anexando al final del archivo si este existe, \texttt{'b'} modo binario, \texttt{'t'} es modo de texto que está por defecto, \texttt{'+'} para abrir y actualizar (leer y escribir) 
\end{itemize}

Los archivos abiertos en el modo binario retornan el contenido como objetos byte sin ninguna decodificación; en el modo texto, el contenido se lee como string.

\subsubsection{Concatenación especial de cadenas de caracteres.}

una forma interesante de hacer concatenación de caracteres es mediante la siguiente forma. Sea \texttt{score=0} una variable del tipo \texttt{int}. Si hacemos \texttt{print(f"your score is {score}")} se hará la conversión de entero a caracter automáticamente sin la necesidad de hacer \texttt{print("your score is" + str(score)")}





\section{Errores y debuggeo de los mismos}

\subsection{Tipos de testeo}

\subsubsection{Test unitario}

Si el programa es modular, es posible hacer tests que aseguren que cada función hace lo que se supone que debe hacer según las especificaciones.

\subsubsection*{Test de regresión}

Cada vez que se soluciona un error, se realiza testeo nuevamente del código, con el objetivo de asegurarse que al realizar la corrección no se agregaron nuevos errores. 

\subsubsection*{Test de integración}

Realizar testeo del programa como un todo. Se ponen juntas cada una de las partes individuales 

\subsubsection{back box testing}

Se tiene el código y se realizan las pruebas con diferentes casos con el fin de encontrar todas las rutas posibles que hay en el código.

Se determina el docstring de una función, ejemplo: \\

\begin{verbatim}
    def sqrt(x,eps)
        """Asume x y eps como flotantes, mayores que cero o igual para x, y retorna un res tal que x-eps <= res <= x+eps
\end{verbatim}

La idea es entonces realizar testeos de diferentes casos dadas las especificaciones del docstring. 

En el caso del ejemplo anterior, se puede hacer un conjunto de pruebas con valores como raíces cuadradas perfectas, números irracionales, menores que 1, o por ejemplo con valores extremos como muy pequeño y muy grandes de ambos \texttt{x} y \texttt{eps}.

\subsubsection{glass box testing}

En este caso lo que se hace es utilizar directamente el código para guiar los casos de prueba. En este caso se pueden llegar a presentar muchas posibilidades de caminos disponibles, teniendo en cuenta la posible presencia de bucles y repeticiones en el código.
Pr ejemplo, para ramas en los que hay diferentes casos, es importante lograr hacer la prueba para todos y cada uno de los posibles caminos o casos. Para bucles \texttt{for}, se deben preparar pruebas en las que no se entra a dicho bucle, también pruebas en las que se entra una vez, dos veces, tres y así sucesivamente. Para bucles \texttt{while} es de manera similar, pero asegurándose de tener casos de prueba que puedan cubrir todas la formas posibles de romper el bucle.

Hacer el debugging tiene una variedad grande de posibilidades. Utilizar \texttt{print}, por ejemplo, dentro de funciones o bucles.

\subsection{Errores}

\subsubsection{\texttt{IndexError}}

\begin{verbatim}
    test[1,2,3]
    test[4]
\end{verbatim}

\subsubsection{\texttt{TypeError}}

\texttt{int(test)}

\subsubsection{\texttt{NameError}} cuando no se encuentra un nombre ya sea local o global.

\texttt{a}
una variable inexistente.

\subsubsection{\texttt{SyntaxError}}

Errores de sintaxis. Cuando python no puede interpretar o analizar gramaticalmente el código.


\subsubsection{\texttt{AttributeError}} las referencias a atributos falla.


\subsubsection{\texttt{ValueError}} el tipo de operador está correcto, pero el valor del mismo es imposible.


\subsubsection{\texttt{IOError}} El sistema IO reporta una malfunción (por ejemplo un archivo no encontrado). Los errores son llamados excepciones.

ahora por alguna razón esto no deja seguir y continuar


\subsection{Handlers}

Los llamados manejadores, son lo que se encargan de llevar a cabo la rutina o ejecución necesaria cuando determinada cosa ocurre, sean interrupciones o excepciones.

\begin{verbatim}
    try:
        xxxxxxx
        xxxxxx
    except (exception_type1):
        xxxxxx
        xxxxx
    except (exception_type2):
        xxxxxx
        xxxxx
        .
        .
        .
\end{verbatim}


\begin{verbatim}
    else:
\end{verbatim}

lo anterior se ejecuta cuando el cuerpo del \texttt{try} asociado se ejecuta sin ninguna excepción.

\begin{verbatim}
    finally:
\end{verbatim}

Siempre se ejecuta después del \texttt{try}, \texttt{else}, y \texttt{except}, incluso cuando existen \texttt{break}, \texttt{continue} o \texttt{return}.

\begin{verbatim}
    raise <ExceptionName> (<Arguments>)
    raise <ValueError> ("Uis, algo esta mal")
\end{verbatim}

\subsection{assertions}

programación "defensiva". 

\begin{verbatim}
    assert <lo_que_se_espera>, <mensaje>
\end{verbatim}

Da un error de ejecución del tipo \texttt{AssertError}. dando la explicación pertinente.

Ahora hay errores lógicos que son más complicados de tratar. 

Cosas que no se deben hacer:

\begin{enumerate}
    \item Escribir el código entero para hacer pruebas sobre él
    \item Hacer debug en el programa entero
    \item Olvidar en qué lugar estaba el bug
    \item Olvidar cuáles fueron los cambios que se hicieron
\end{enumerate}

Por el contrario es más recomendable escribir una función, probarla, hacer depuración, y así con cada función nueva que se escriba. Hacer Testeo de integración. 
También hacer copias de seguridad del código, cambiarlo, advertir mediante comentarios los cambios, y al realizar pruebas, hacer comparaciones.













\section{POO}

\texttt{object} es el tipo más básico en python.

\begin{verbatim}
    class <name>(<parent_class>):
\end{verbatim}

\begin{verbatim}
    class coordinate(object):
        def __init__(self, x, y):
            self.x = x
            self.y = y
\end{verbatim}

El \texttt{self} es un parámetro para referirse a la instancia de la clase, la que esté ejecutándose. El constructor siempre será \texttt{def \_\_init\_\_():}\\

\subsection{Métodos importantes}

Estos métodos sustituyen operadores o funciones importantes.

\begin{itemize}
    \item \texttt{\_\_str\_\_():} Su retorno es lo que se muestra cuando se ejecuta la función \texttt{print()}
    \item \texttt{\_\_add\_\_():} Su retorno es el valor de 'a+b'.
    \item \texttt{\_\_sub\_\_():} Su retorno es el valor de 'a-b'.
    \item \texttt{\_\_mul\_\_():} Su retorno es el valor de 'a*b'.
    \item \texttt{\_\_eq\_\_():} Su retorno es el valor de 'a==b'.
    \item \texttt{\_\_lt\_\_():} Su retorno es el valor de 'a<b'.
    \item \texttt{\_\_len\_\_():} Su retorno es el valor de 'len(a)'.
\end{itemize}

\textbf{nota} las \textbf{variables de clase} son variables cuyo valor se comparte entre todas las instancias de la clase 



\section{Sobre algoritmos}

¿Cómo se puede establecer o sabe qué tan eficiente es mi algoritmo? 

Los razonamientos que surgen a partir de este punto dan como resultado un análisis interesante sobre las siguientes cuestiones:

\begin{itemize}
    \item Cómo podemos razonar sobre un algoritmo con el objetivo de predecir la cantidad de tiempo que este necesitará para resolver un problema de un tamaño en particular.
    \item Cómo podemos relacionar las opciones en el diseño de algoritmos con la eficiencia en tiempo del resultado.
\end{itemize}


\section{Sobre desarrollo de Software}

Cuando se requiere crear un Software, similar a como se planea la construcción de una cada, el primer paso siempre es tener un esquema que qué es exactamente lo que se quiere construir. Cuál es el objetivo principal que dicho Software quiere cumplir. Después de este paso, viene la fase de diseño; está compuesta por los desarrolladores y los arquitectos. Se determina cómo se trabajará, los lineamientos, etc. Una vez el diseño está finalizado, viene la parte del código; la implementación de aquello que se quiere implementar. Cada sub equipo va a realizar pruebas y tests de cada componente. Una vez todos los componentes están listos, es el momento de realizar la unción de dichos componentes, y se realizan las pruebas de integración, pruebas de funcionalidad. Cuando todo está listo, se viene la fase de producción, operación y mantenimiento. Esto implca que el usuario empezará a utilizar el Software, y es cuando pueden venir requerimientos como cambios, mejoras, etc. Las fases se pueden resumir como sigue

\begin{itemize}
    \item Requierimientos
    \item Diseño.
    \item Implementación.
    \item Verificación.
    \item Operación y manteniemiento.
\end{itemize}

En muchas ocasiones puede presentarse situaciones en las que los desarrolladores o los arquitectos pueden malinterpetar los requerimientos del usuario, este malentendido puede extenderse a las fases posteriores. Esto hace importante tener muy en cuenta diferentes modelos que permitan disminuir al máximo este tipo de situaciones. Un concepto importante de algo que parece ser más que un modelo es el llamado 'Agile'. \\

Se trata de un enfoque de desarrollo que se enfatiza en la flexibilidad, la colaboración y el desarrollo iterativo. Este desarrollo implica la división del proyecto en varias iteracione que típicamente tienen una duración de una a cuatro semanas. cada iteración se concentra en entregar un incremento en la producctión del trabajo. Esto permite un arealimentación más frecuente y la habilidad de adaptarse y realizar cambios en caso de ser necesario. Agile también promueve la colaboración cercana entre los desarrolladores y el cliente. El cliente está mas involucrado en el proceso de desarrollo, proveyendo retroalimentación y clarificando los requerimientos. También reconoce que los requerimientos y las prioridades pueden cambiar a lo largo del tiempo. En lugar de tratar de predecir y planear cada detalle, la idea es abrazar los cambios y ajustar los planes a medida de las nuevas informaciones. Esto permite una gran flexibilidad, y la habilidad de responder a las necesidades cambiantes de los clientes. Los miembros de los equipos colaboran de cerca, cimparten responsabilidades y toman decisiones de manera colectiva. Siempre se enfocan en el mejoramiento continuo. 

\subsection{Requerimientos}

El hecho de que un Software sea un objeto intangible, hace bastante más complicado comunicar ideas de manera exacta, sobre verdaderamente qué es lo que se pretende y delimitar los requerimientos de un software. Un requerimiento tiene esencialmente dos definiciones. El primero es definido como un proceso, en el cual se elabora una idea compartida sobre el problema que existe y eventualmente la potencial solución al mismo. Se construye un conjunto de descripciones de alto nivel de cada parte que compone el probema. El principal objetivo es elaborar un documento que pueda describir detalladamente qué es lo que el sistema deberá hacer y qué es lo que el sistema no deberá hacer. Es impotante tener en cuenta más el 'qué' que el 'cómo', se quiere determinar el comportamiento que tendrá la solución sin tomar decisiones prematuras que puedan afectar la habilidad de diseñar la solución. Este diseño no se realiza todavía en este paso. El segundo concepto de especificación de requerimiento, es el producto de este proceso; la documentación que sale como producto de este proceso. \\

La especificación de los requerimientos son muy importantes debido a dos aspectos particulares: Por la parte de ingeniería, la importancia recae en el hecho de que así se evita cometer diversos errores que pueden desencadenar en pérdidas de tiempo. Está demostrado que un mayor porcentaje de tiempo invertido en el proceso de especificación de requerimientos da como resultado un mejor porcentaje de costos por imprevistos.

\subsection{Modelo WRSPM}

El modelo WRSPM, también conocido como el modelo mundo-máquina, es un modelo que permite esquematizar y entender los requerimientos del usuario y determinar las especificaciones necesarias de Software para resolver el problema. El modelo consiste en cinco elementos: W (world), R (requirements), S (specifications), P (program), y M (machine). Las suposiciones del mundo son aquellas cosas que ya están dadas por sentadas dentro del universo del probema. Los requerimientos son los objetivos del usuario, aquello que el usuario quiere lograr. Las especificaciones 'S' definen cómo el sistema va a cumplir esos requerimientos. El programa ya está inmerso en el conjunto del sistema, y es, de hecho, el cógido o conjuntos de códigos escritos por los programadores; el programa que cumplirá las especificaciones. Finalmente M es la máquina; el conjunto de hardware que compone la solución. \\

En este sistema tenemos cuatro variables interesantes: $e_h$, $e_v$, $s_v$, y $s_h$. $e_h$ son los elementos del entorno que están ocultos al sistema, fuera del sistema, pero aún nos preocupa. Un ejemplo puede ser la tarjeta de crédito que el usuario necesita para poder retirar del cajero. El conjuinto $e_v$ es el de las partes visibles para el sistema en el entorno. En nuestro ejemplo, son los datos generadeos al leer la cinta magnética de la tarjeta de crédito, y el número PIN introducido. EN esencia, cualquier dato que puede ser leído o introducido en el sistema, pues este lo puede leer y es visible. Los $s_v$ son los elementos del sistema que están visibles en el entorno. Esto puede comprender los botones del cajero, la información en pantalla, etc. Finalmente, los $s_h$ son los elementos del sistema que no son visibles para usuarios; que están escondidos internamente en el código, en el hardware, y demás. 

\subsubsection{Ejemplo WRSPM} Un ejemplo para ilustrar los elementos que componen el modelo. Sea un monitor de paciente, capaz de leer signos vitales como fercuencia cardíaca, pulso, presión arterial, etc. El deseo u objetivo del monitor, es tener un sistema de alerta que notifique a la enfermera si el corazón del paciente se detiene. Esto da como requerimiento real el siguiente: si el corazón del paciente se detiene, se debe avisar a la enfermera. Eso se traduce dentro del sistema de la siguiente manera: si el sonido de un sensor cae por debajo de un umbral establecido, se activará una alarma. Un elemento clave es analizar una de las posibilidades de la parte 'W' del entorno. Se da por sentado que si la alarma suena, siempre habrá una enfermera que escuche y entienda que el corazón se detuvo. Este y muchos otros elementos que se asumen del entorno (y que por tanto no hacen parte del sistema) deben ser cuidadosamente estudiados y tenidos en cuenta dentro de la elaboración de los requerimientos y posteriores especifucaciones.  